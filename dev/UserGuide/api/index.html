<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · IFTDuals.jl</title><meta name="title" content="API Reference · IFTDuals.jl"/><meta property="og:title" content="API Reference · IFTDuals.jl"/><meta property="twitter:title" content="API Reference · IFTDuals.jl"/><meta name="description" content="Documentation for IFTDuals.jl."/><meta property="og:description" content="Documentation for IFTDuals.jl."/><meta property="twitter:description" content="Documentation for IFTDuals.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">IFTDuals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">User Documentation</span><ul><li><a class="tocitem" href="../limitations/">Limitations</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Implicit-function-signature-requirements"><span>Implicit function signature requirements</span></a></li></ul></li><li><a class="tocitem" href="../advanced/">Advanced Usage</a></li></ul></li><li><a class="tocitem" href="../../dev/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Documentation</a></li><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Garren-H/IFTDuals.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Garren-H/IFTDuals.jl/blob/master/docs/src/UserGuide/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>IFTDuals exports the following functions</p><h3 id="Main-function"><a class="docs-heading-anchor" href="#Main-function">Main function</a><a id="Main-function-1"></a><a class="docs-heading-anchor-permalink" href="#Main-function" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="IFTDuals.ift"><a class="docstring-binding" href="#IFTDuals.ift"><code>IFTDuals.ift</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">    function ift(y::Union{V,&lt;:AbstractArray{V}},f::Function,args; DT::Type{Union{Nothing,&lt;:Dual}}=nothing, tag_is_mixed::Union{Nothing,Bool}=nothing, args_needs_promotion::Bool=true) where {V&lt;:Real}
    function ift(y::Union{V,&lt;:AbstractArray{V}},f::Function,args,args_primal; DT::Type{Union{Nothing,&lt;:Dual}}=nothing, tag_is_mixed::Union{Nothing,Bool}=nothing, args_needs_promotion::Bool=true) where {V&lt;:Real}</code></pre><p>Function to compute higher-order derivatives using the implicit function theorem (IFT) and (nested) Dual numbers.  Input:</p><ul><li><code>y</code>    : primal input solution to the root finding problem (scalar or vector)</li><li><code>f</code>    : function handle that takes &#39;y&#39; and &#39;args&#39; as inputs. <code>f(y,args) = 0</code> is assumed to define the implicit relationship between <code>y</code> and values given as <code>args</code>.</li><li><code>args</code> : tuple or data structure containing Dual numbers indicating the differentiation structure</li><li><code>args_primal</code> : primal values of <code>args</code></li></ul><p>Optional Input:</p><ul><li><code>DT</code>                  : Target Dual type for the output. If not provided, it is inferred from <code>args</code>.</li><li><code>tag_is_mixed</code>        : Boolean indicating if mixed tags are present in <code>args</code>. If not provided, it is inferred from <code>args</code>.</li><li><code>args_needs_promotion</code>: Boolean indicating if <code>args</code> need to be promoted to a common Dual type.</li></ul><p>Output:</p><ul><li>Returns <code>y</code> as a Dual number with the appropriate order and partial derivatives computed using the IFT.</li></ul><p>The function works by first determining the order of differentiation and whether mixed tags are present.</p><div class="admonition is-warning" id="Warning-cea373ac46148118"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-cea373ac46148118" title="Permalink"></a></header><div class="admonition-body"><p>When mixed tags are detected, but <code>tag_is_mixed=false</code> is provided, a check is performed to ensure that the number of partials are consistent across the Dual types in <code>args</code>. If inconsistencies are found, an error is thrown. No other checks are performed and it is the user&#39;s responsibility to ensure symmetry of partial derivatives in this case.</p></div></div><div class="admonition is-warning" id="Warning-3fb165e6810472b5"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-3fb165e6810472b5" title="Permalink"></a></header><div class="admonition-body"><p>If <code>args_needs_promotion=false</code> is provided, it is the user&#39;s responsibility to ensure that all Dual types in <code>args</code> are of the same type. If the Dual type differs, unexpected behavior may occur.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/eb534e36d4d574e3b89491c77df0ea0fbe8a3f74/src/derivatives.jl#L263-L287">source</a></section></details></article><p>The <code>ift</code> function is the core function for computing higher-order derivatives. Using this function will work for most use cases without needing to overload the utility functions. It is a requirement that all functions called on <code>y</code> and <code>args</code> use <code>AbstractArray</code> annotations and not concrete <code>Vector</code>, <code>Matrix</code> or <code>Array</code> types. Internally <code>ift</code> calls some functions which convert arrays of duals into <code>AbstractArray</code> types, to avoid allocating new arrays and hence improve performance.</p><p>The <code>ift</code> function has several optional keyword arguments to optimize performance in specific scenarios. These are described in detail in the <a href="../advanced/#Advanced-Usage">Advanced Usage</a> section of the user guide.</p><h3 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="IFTDuals.pvalue"><a class="docstring-binding" href="#IFTDuals.pvalue"><code>IFTDuals.pvalue</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">    pvalue(x::V) where V
    pvalue(::Type{V}) where V</code></pre><p>Extracts the value field of Duals contained within generic data structures. <code>pvalue(x::V)</code> return <code>ForwardDiff.value(x)</code>, and <code>pvalue(::Type{V})</code> returns <code>ForwardDiff.valtype(V)</code>. For structures containing multiple types (e.g. Tuples, Structs, Arrays of  structs, Dicts) it loops through all fields/entries in the data structure and performs <code>pvalue</code> on each entry. For custom structs it  is recommended to provide your own method for <code>pvalue</code> which only applies pvalue to the fields which may contain Duals.</p><p>Example:</p><pre><code class="language-julia hljs">struct MyStruct{T1&lt;:Real,T2&lt;:Real}
    a::T1 # variable which may contain Duals
    b::String # non-numeric variable
    c::T2 # variable which may contain Duals
end

pvalue(x::MyStruct{T1,T2}) where {T1&lt;:Real,T2&lt;:Real} = MyStruct{pvalue(T1),pvalue(T2)}(pvalue(x.a), x.b, pvalue(x.c)) # construct new struct with primal eltypes, need not loop through all fields</code></pre><p>We encourage the usage of <code>pvalue</code> to ensure <code>x.a</code> and/or <code>x.c</code> are correctly handled if they are custom structs themselves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/eb534e36d4d574e3b89491c77df0ea0fbe8a3f74/src/utils.jl#L18-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.nested_pvalue"><a class="docstring-binding" href="#IFTDuals.nested_pvalue"><code>IFTDuals.nested_pvalue</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">    nested_pvalue(::Type{V}) where V
    nested_pvalue(x::V) where V</code></pre><p>Extracts the innermost primal value or types from generic structures containing Duals. It recursively applies  <code>pvalue</code> until the innermost primal value/type is not a Dual. Similar to <code>pvalue</code>, for custom structs <code>nested_pvalue</code> is aplied to all fields in the struct. For custom structs it is recommended to provide  your own method for <code>nested_pvalue</code>, similar to <code>pvalue</code>. </p><p>Example:</p><pre><code class="language-julia hljs">struct MyStruct{T1&lt;:Real,T2&lt;:Real}
    a::T1 # variable which may contain Duals
    b::String # non-numeric variable
    c::T2 # variable which may contain Duals
end

nested_pvalue(x::MyStruct{T1,T2}) where {T1&lt;:Real,T2&lt;:Real} = MyStruct{nested_pvalue(T1),nested_pvalue(T2)}(nested_pvalue(x.a), x.b, nested_pvalue(x.c))</code></pre><p>We encourage the usage of <code>nested_pvalue</code> to ensure <code>x.a</code> and/or <code>x.c</code> are correctly handled if they are custom structs themselves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/eb534e36d4d574e3b89491c77df0ea0fbe8a3f74/src/utils.jl#L87-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.promote_common_dual_type"><a class="docstring-binding" href="#IFTDuals.promote_common_dual_type"><code>IFTDuals.promote_common_dual_type</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">    promote_common_dual_type(x::V, DT::Type{&lt;:Dual}) where V
    promote_common_dual_type(::Type{V1}, ::Type{V2}) where {V1,V2}</code></pre><p>Promotes Dual numbers in generic data structures to a common Dual type <code>DT</code> by using <code>Base.convert</code>. Or when called on types, it checks if <code>V1</code> can be promoted to <code>V2</code> and returns <code>V2</code> if possible. For structs, the current implementation applies <code>promote_common_dual_type</code> to all fields in the struct and attempts to reconstruct the struct using the promoted values. It is hence recommended to provide  your own method for custom structs which only promotes the relevant fields.</p><p>Example:</p><pre><code class="language-julia hljs">struct MyStruct{T1&lt;:Real,T2&lt;:Real}
    a::T1 # variable which may contain Duals
    b::String # non-numeric variable
    c::T2 # variable which may contain Duals
end

promote_common_dual_type_structs(x::MyStruct{T1,T2},DT::Type{&lt;:Dual}) where {T1&lt;:Real,T2&lt;:Real} = begin 
    TT1 = promote_common_dual_type(T1, DT) # should be DT, but internally checks that this conversion is possible
    TT2 = promote_common_dual_type(T2, DT) # should be DT, but internally checks that this conversion is possible
    MyStruct{TT1,TT2}(promote_common_dual_type(x.a,DT), x.b, promote_common_dual_type(x.c,DT))
end
promote_common_dual_type(x::MyStruct{T,T},DT::Type{T}) where T = x # already desired type</code></pre><p>We encourage the usage of <code>promote_common_dual_type</code> to ensure <code>x.a</code> and/or <code>x.c</code> are correctly handled if they are custom structs themselves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/eb534e36d4d574e3b89491c77df0ea0fbe8a3f74/src/utils.jl#L163-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.promote_my_type"><a class="docstring-binding" href="#IFTDuals.promote_my_type"><code>IFTDuals.promote_my_type</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">    promote_my_type(::Type{T}) where T
    promote_my_type(x::T) where T</code></pre><p>Get the common numeric supertype (Duals) from generic data structures. For non-numeric types  (String, Symbol, Nothing, Missing, Function), it returns Nothing. For custom data structures the current implementation checks all (nested) fields for numeric types, extracts these numeric types and reduces <code>Base.promote_type</code> over all numeric types found. It is hence highly recommended  to provide your own method for custom data structures.</p><p>Example:</p><pre><code class="language-julia hljs">struct MyStruct{T1&lt;:Real,T2&lt;:Real}
    a::T1 # variable which may contain Duals
    b::String # non-numeric variable
    c::T2 # variable which may contain Duals
end

promote_my_type(::MyStruct{T1,T2}) where {T1&lt;:Real,T2&lt;:Real} = promote_my_type(T1,T2)
promote_my_type(::Type{MyStruct{T1,T2}}) where {T1&lt;:Real,T2&lt;:Real} = promote_my_type(T1,T2) # needed if promote_my_type is called on Type</code></pre><p>The above implementation uses <code>promote_my_type</code>, but in this specific case one could use <code>promote_type</code> directly:</p><pre><code class="language-julia hljs">promote_my_type(::MyStruct{T1,T2}) where {T1&lt;:Real,T2&lt;:Real} = promote_type(T1,T2)
promote_my_type(::Type{MyStruct{T1,T2}}) where {T1&lt;:Real,T2&lt;:Real} = promote_type(T1,T2)</code></pre><p>We encourage the usage of <code>promote_my_type</code> to ensure <code>T1</code> and/or <code>T2</code> are correctly handled if they are custom structs themselves. If the struct signature does not contain type information, we perform the promotion on the fields instead:</p><pre><code class="language-julia hljs">promote_my_type(x::MyStruct) = promote_my_type(x.a, x.c)</code></pre><p>If <code>MyStruct</code> contained a single numeric field (which may contain duals), <code>MyStruct{T} where T&lt;:Real</code>, we would  return <code>promote_my_type(T)</code>. </p><div class="admonition is-info" id="Note-b8d957ad8eb0f3c5"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b8d957ad8eb0f3c5" title="Permalink"></a></header><div class="admonition-body"><p>This is hence a combination of <code>Base.eltype</code> and <code>Base.promote_type</code> but specialized to only consider numeric types</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/eb534e36d4d574e3b89491c77df0ea0fbe8a3f74/src/utils.jl#L255-L296">source</a></section></details></article><h2 id="Implicit-function-signature-requirements"><a class="docs-heading-anchor" href="#Implicit-function-signature-requirements">Implicit function signature requirements</a><a id="Implicit-function-signature-requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-function-signature-requirements" title="Permalink"></a></h2><p>The <code>ift</code> function only supports the two-argument function signature <code>f(x, args)</code>. If your implicit function requires multiple separate parameter arguments, you should define <code>args</code> as a tuple and use splatting within your function:</p><pre><code class="language-julia hljs"># If you have a function with multiple parameters
function my_function(x, α, β, γ)
    return ... # some operation
end

# Wrap it to use the f(y, theta) signature
f(x, args) = my_function(x, args...)

# Define theta as a tuple of parameters
args = (α, β, γ)

# Now you can use ift
x_dual = ift(x, f, args)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../limitations/">« Limitations</a><a class="docs-footer-nextpage" href="../advanced/">Advanced Usage »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 20 February 2026 16:58">Friday 20 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
