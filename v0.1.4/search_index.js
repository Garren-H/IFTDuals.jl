var documenterSearchIndex = {"docs":
[{"location":"UserGuide/limitations/#Limitations","page":"Limitations","title":"Limitations","text":"IFTDuals.jl was designed to work with ForwardDiff.jl and its dual number implementation. It is not intended to work (nor will it work) with any other AD packages. Other then the limitations of ForwardDiff.jl, no other limitations are known at this time.","category":"section"},{"location":"UserGuide/api/#API-Reference","page":"API Reference","title":"API Reference","text":"IFTDuals exports the following functions","category":"section"},{"location":"UserGuide/api/#Main-function","page":"API Reference","title":"Main function","text":"The ift function is the core function for computing higher-order derivatives. Using this function will work for most use cases without needing to overload the utility functions. It is a requirement that all functions called on y and args use AbstractArray annotations and not concrete Vector, Matrix or Array types. Internally ift calls some functions which convert arrays of duals into AbstractArray types, to avoid allocating new arrays and hence improve performance.\n\nThe ift function has several optional keyword arguments to optimize performance in specific scenarios. These are described in detail in the Advanced Usage section of the user guide.","category":"section"},{"location":"UserGuide/api/#Utility-functions","page":"API Reference","title":"Utility functions","text":"","category":"section"},{"location":"UserGuide/api/#Implicit-function-signature-requirements","page":"API Reference","title":"Implicit function signature requirements","text":"The ift function only supports the two-argument function signature f(x, args). If your implicit function requires multiple separate parameter arguments, you should define args as a tuple and use splatting within your function:\n\n# If you have a function with multiple parameters\nfunction my_function(x, α, β, γ)\n    return ... # some operation\nend\n\n# Wrap it to use the f(y, theta) signature\nf(x, args) = my_function(x, args...)\n\n# Define theta as a tuple of parameters\nargs = (α, β, γ)\n\n# Now you can use ift\nx_dual = ift(x, f, args)","category":"section"},{"location":"UserGuide/api/#IFTDuals.ift","page":"API Reference","title":"IFTDuals.ift","text":"    function ift(y::Union{V,<:AbstractArray{V}},f::Function,args; DT::Type{Union{Nothing,<:Dual}}=nothing, tag_is_mixed::Union{Nothing,Bool}=nothing, args_needs_promotion::Bool=true) where {V<:Real}\n    function ift(y::Union{V,<:AbstractArray{V}},f::Function,args,args_primal; DT::Type{Union{Nothing,<:Dual}}=nothing, tag_is_mixed::Union{Nothing,Bool}=nothing, args_needs_promotion::Bool=true) where {V<:Real}\n\nFunction to compute higher-order derivatives using the implicit function theorem (IFT) and (nested) Dual numbers.  Input:\n\ny    : primal input solution to the root finding problem (scalar or vector)\nf    : function handle that takes 'y' and 'args' as inputs. f(y,args) = 0 is assumed to define the implicit relationship between y and values given as args.\nargs : tuple or data structure containing Dual numbers indicating the differentiation structure\nargs_primal : primal values of args\n\nOptional Input:\n\nDT                  : Target Dual type for the output. If not provided, it is inferred from args.\ntag_is_mixed        : Boolean indicating if mixed tags are present in args. If not provided, it is inferred from args.\nargs_needs_promotion: Boolean indicating if args need to be promoted to a common Dual type.\n\nOutput:\n\nReturns y as a Dual number with the appropriate order and partial derivatives computed using the IFT.\n\nThe function works by first determining the order of differentiation and whether mixed tags are present.\n\nwarning: Warning\nWhen mixed tags are detected, but tag_is_mixed=false is provided, a check is performed to ensure that the number of partials are consistent across the Dual types in args. If inconsistencies are found, an error is thrown. No other checks are performed and it is the user's responsibility to ensure symmetry of partial derivatives in this case.\n\nwarning: Warning\nIf args_needs_promotion=false is provided, it is the user's responsibility to ensure that all Dual types in args are of the same type. If the Dual type differs, unexpected behavior may occur.\n\n\n\n\n\n","category":"function"},{"location":"UserGuide/api/#IFTDuals.pvalue","page":"API Reference","title":"IFTDuals.pvalue","text":"    pvalue(x::V) where V\n    pvalue(::Type{V}) where V\n\nExtracts the value field of Duals contained within generic data structures. pvalue(x::V) return ForwardDiff.value(x), and pvalue(::Type{V}) returns ForwardDiff.valtype(V). For structures containing multiple types (e.g. Tuples, Structs, Arrays of  structs, Dicts) it loops through all fields/entries in the data structure and performs pvalue on each entry. For custom structs it  is recommended to provide your own method for pvalue which only applies pvalue to the fields which may contain Duals.\n\nExample:\n\nstruct MyStruct{T1<:Real,T2<:Real}\n    a::T1 # variable which may contain Duals\n    b::String # non-numeric variable\n    c::T2 # variable which may contain Duals\nend\n\npvalue(x::MyStruct{T1,T2}) where {T1<:Real,T2<:Real} = MyStruct{pvalue(T1),pvalue(T2)}(pvalue(x.a), x.b, pvalue(x.c)) # construct new struct with primal eltypes, need not loop through all fields\n\nWe encourage the usage of pvalue to ensure x.a and/or x.c are correctly handled if they are custom structs themselves.\n\n\n\n\n\n","category":"function"},{"location":"UserGuide/api/#IFTDuals.nested_pvalue","page":"API Reference","title":"IFTDuals.nested_pvalue","text":"    nested_pvalue(::Type{V}) where V\n    nested_pvalue(x::V) where V\n\nExtracts the innermost primal value or types from generic structures containing Duals. It recursively applies  pvalue until the innermost primal value/type is not a Dual. Similar to pvalue, for custom structs nested_pvalue is aplied to all fields in the struct. For custom structs it is recommended to provide  your own method for nested_pvalue, similar to pvalue. \n\nExample:\n\nstruct MyStruct{T1<:Real,T2<:Real}\n    a::T1 # variable which may contain Duals\n    b::String # non-numeric variable\n    c::T2 # variable which may contain Duals\nend\n\nnested_pvalue(x::MyStruct{T1,T2}) where {T1<:Real,T2<:Real} = MyStruct{nested_pvalue(T1),nested_pvalue(T2)}(nested_pvalue(x.a), x.b, nested_pvalue(x.c))\n\nWe encourage the usage of nested_pvalue to ensure x.a and/or x.c are correctly handled if they are custom structs themselves.\n\n\n\n\n\n","category":"function"},{"location":"UserGuide/api/#IFTDuals.promote_common_dual_type","page":"API Reference","title":"IFTDuals.promote_common_dual_type","text":"    promote_common_dual_type(x::V, DT::Type{<:Dual}) where V\n    promote_common_dual_type(::Type{V1}, ::Type{V2}) where {V1,V2}\n\nPromotes Dual numbers in generic data structures to a common Dual type DT by using Base.convert. Or when called on types, it checks if V1 can be promoted to V2 and returns V2 if possible. For structs, the current implementation applies promote_common_dual_type to all fields in the struct and attempts to reconstruct the struct using the promoted values. It is hence recommended to provide  your own method for custom structs which only promotes the relevant fields.\n\nExample:\n\nstruct MyStruct{T1<:Real,T2<:Real}\n    a::T1 # variable which may contain Duals\n    b::String # non-numeric variable\n    c::T2 # variable which may contain Duals\nend\n\npromote_common_dual_type_structs(x::MyStruct{T1,T2},DT::Type{<:Dual}) where {T1<:Real,T2<:Real} = begin \n    TT1 = promote_common_dual_type(T1, DT) # should be DT, but internally checks that this conversion is possible\n    TT2 = promote_common_dual_type(T2, DT) # should be DT, but internally checks that this conversion is possible\n    MyStruct{TT1,TT2}(promote_common_dual_type(x.a,DT), x.b, promote_common_dual_type(x.c,DT))\nend\npromote_common_dual_type(x::MyStruct{T,T},DT::Type{T}) where T = x # already desired type\n\nWe encourage the usage of promote_common_dual_type to ensure x.a and/or x.c are correctly handled if they are custom structs themselves.\n\n\n\n\n\n","category":"function"},{"location":"UserGuide/api/#IFTDuals.promote_my_type","page":"API Reference","title":"IFTDuals.promote_my_type","text":"    promote_my_type(::Type{T}) where T\n    promote_my_type(x::T) where T\n\nGet the common numeric supertype (Duals) from generic data structures. For non-numeric types  (String, Symbol, Nothing, Missing, Function), it returns Nothing. For custom data structures the current implementation checks all (nested) fields for numeric types, extracts these numeric types and reduces Base.promote_type over all numeric types found. It is hence highly recommended  to provide your own method for custom data structures.\n\nExample:\n\nstruct MyStruct{T1<:Real,T2<:Real}\n    a::T1 # variable which may contain Duals\n    b::String # non-numeric variable\n    c::T2 # variable which may contain Duals\nend\n\npromote_my_type(::MyStruct{T1,T2}) where {T1<:Real,T2<:Real} = promote_my_type(T1,T2)\npromote_my_type(::Type{MyStruct{T1,T2}}) where {T1<:Real,T2<:Real} = promote_my_type(T1,T2) # needed if promote_my_type is called on Type\n\nThe above implementation uses promote_my_type, but in this specific case one could use promote_type directly:\n\npromote_my_type(::MyStruct{T1,T2}) where {T1<:Real,T2<:Real} = promote_type(T1,T2)\npromote_my_type(::Type{MyStruct{T1,T2}}) where {T1<:Real,T2<:Real} = promote_type(T1,T2)\n\nWe encourage the usage of promote_my_type to ensure T1 and/or T2 are correctly handled if they are custom structs themselves. If the struct signature does not contain type information, we perform the promotion on the fields instead:\n\npromote_my_type(x::MyStruct) = promote_my_type(x.a, x.c)\n\nIf MyStruct contained a single numeric field (which may contain duals), MyStruct{T} where T<:Real, we would  return promote_my_type(T). \n\nnote: Note\nThis is hence a combination of Base.eltype and Base.promote_type but specialized to only consider numeric types\n\n\n\n\n\n","category":"function"},{"location":"dev/#How-IFTDuals-work","page":"Developer Documentation","title":"How IFTDuals work","text":"As mentioned, the IFT gives a generic way in which one can compute higher-order derivatives of implicit functions.\n\nfracd^K xd theta^K = - left( fracpartial fpartial x right)^-1 B_K\n\nWhere B_K=fracd^K fd theta^K - fracpartial fpartial x fracd^K xd theta^K. The core idea of IFTDuals.jl is using dual numbers (specifically ForwardDiff.jl) and starting from the inner most Dual, compute B_K using AD, solve for the derivative, convert the result back into a dual and repeat the process until all dual levels have been processed.\n\nTo achieve this, all that is required is to seed x appropriately at each level and B_K will be recovered as the partials field. That is, for the inner most dual (1st order derivative), x is seeded with zero (or just using the primal value), resulting in B_1 being given as\n\nB_1 = fracpartial fpartial theta\n\nNow we reconstruct the dual number for the first order derivative\n\nx_dual1 = DT1(x, PT1((dx_dtheta,))) # DT1 -> Dual Type for level 1, PT1 -> Partial Type for level 1\n\nNow to obtain the second order derivative, we need to seed x_dual1 appropriately. If the partials are symmetric, then we seed\n\nx_dual2_star = DT2(x_dual1, PT2(ntuple(j -> DT1(x_dual.partials[j]),length(x)))) # DT2 -> Dual Type for level 2, PT2 -> Partial Type for level 2\n\nThe evaluation of f at x_dual2_star and the second order dual args will yield B_2 as the partials.partials field (this can easily be proved by performing the Dual arithmetic). We can then solve for the second order derivative, reconstruct the dual and repeat the process for higher order derivatives. Note that for symmetry of higher partials, we need to seed all partials.value fields with the correct derivatives computed. I.e. for a third order dual, we would need to seed the partials.value.value field with the first order derivatives computed, the partials.partials.value field with the second order derivatives computed and finally compute B_3, extract this as the partials.partials.partials field, solve the system and reconstruct the third order dual. This process is implemented recursively. The source code can be found here. \n\nWhen we do not have symmetry of partials, we are still able to recover the correct B_K terms, but involves a bit more bookeeping. If we have two parameters, θ₁ and θ₂, then for the second order dual, where θ₁ is the inner dual and θ₂ the outer dual. The first step would be convert θ₁ and θ₂ into duals of the same type, i.e. both second order duals where the inner dual has zero partials for θ₂ and the outer dual has zero partials for θ₁. This is easily achieved with Base.promote. The first order dual is then extracted and the above mentioned procedure is followed to obtain dx/dθ₁. To obtain dx/dθ₂, we only need to evaluate f at the second order dual (irrespective of whether x is seeded with dx/dθ₁ or zero) and extract the partials.value field to obtain B_1 for θ₂. Following the Dual arithmetic one will note that the value.partials and partials.value fields are independent of each other. Once both dx/dθ₁ and dx/dθ₂ have been computed, we can reconstruct the second order dual with the correct partials, with zeroed partials.partials field. \n\nx_dual2_star = DT2(DT1(x,PT1((dx_dtheta1,))),PT2((DT1(dx_dtheta2),)))\n\nNow B_2 can be obtained by evaluating f at x_dual2_star and the second order dual args, with B_2 being extracted as the partials.partials field. d²x/dθ₁dθ₂ is then solved for and the second order dual is reconstructed with the correct partials field. For third order duals the same process is followed, fist the partials.value.value and partials.value.partials fields are obtained, followed by the partials.partials.value field and finally B_3 is obtained from the partials.partials.partials field. This process naturally has a recursive structure where two branches of recursion are required, one to solve for the partials.value fields and another to solve for the partials.partials fields. The source code for this implementation can be found here.","category":"section"},{"location":"UserGuide/advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"The ift function accepts several keyword arguments that can improve performance by providing additional information about your differentiation setup. By default, these parameters are auto-detected, but specifying them explicitly can avoid redundant computations.","category":"section"},{"location":"UserGuide/advanced/#Keyword-Arguments","page":"Advanced Usage","title":"Keyword Arguments","text":"ift(y, f, args; DT=nothing, tag_is_mixed=nothing, args_needs_promotion=true)\nift(y, f, args, args_primal; DT=nothing, tag_is_mixed=nothing, args_needs_promotion=true)","category":"section"},{"location":"UserGuide/advanced/#args_primal-Primal-value-of-args-(positional-argument)","page":"Advanced Usage","title":"args_primal - Primal value of args (positional argument)","text":"The ift function can accept the primal value of args as a second positional argument. This is particularly useful because you typically need to compute nested_pvalue(args) to solve for the primal solution y anyway. By passing it to ift, you avoid recomputing it internally:\n\nfunction solve_y(θ)\n    θ_primal = nested_pvalue(θ)  # Compute once\n    y = solve_for_y(θ_primal)     # Use to solve for y\n    return ift(y, f, θ, θ_primal) # Pass to ift to avoid recomputation\nend\n\nPerformance benefit: This eliminates the overhead of calling nested_pvalue(args) inside ift, which can be significant for complex nested structures.","category":"section"},{"location":"UserGuide/advanced/#DT::Union{Nothing,Type{:Dual}}-Target-dual-type","page":"Advanced Usage","title":"DT::Union{Nothing,Type{<:Dual}} - Target dual type","text":"By default, ift automatically detects the dual type from args. If you already know the target dual type, you can specify it to skip the type detection step. This is useful in cases where several variables are passed to args for which only one is of Dual type and the type is know.","category":"section"},{"location":"UserGuide/advanced/#tag_is_mixed::Union{Nothing,Bool}-Whether-tags-are-mixed-(default:-nothing)","page":"Advanced Usage","title":"tag_is_mixed::Union{Nothing,Bool} - Whether tags are mixed (default: nothing)","text":"This is only applicable when computing derivatives of order 2 or higher.\n\nTwo different implementations for IFT exists depending on the Dual structures/tags used in args. If all of the variables share the same Dual Tag, i.e. computing Hessians, second or higher order derivatives for a single variable (or vector/array of variables), the dual structure is symmetric. That is value.partials contains the same information as partials.value. In this case one can specify tag_is_mixed=false to effectively copy value.partials into partials.value, and hence avoid redundant computations. Important to note is depending on how AD is called, different Dual tags can still be created internally, even when differentiating wrt a single variable. There is no way of identifying in this case whether the tags are truly mixed, hence it is left to the user to ensure this is set correctly. When specifying tag_is_mixed=false, an internal check is only conducted on the number of partials per Dual layer, but this is not sufficient to guarantee symmetry. This functionality should hence be used with caution.\n\nIf the variables in args have different Duals Tags, i.e. having multiple variables to differentiate with respect to, the dual structure is not symmetric. A simple use case here is computing cross-derivatives, e.g. having a function g(x1, x2) and wanting to compute d²g/dx1dx2. In this case the value.partials and partials.value fields are assymetric and both needs to be computed seperately. In most cases this will be the default due to the mixed tag creation mentioned above. ","category":"section"},{"location":"UserGuide/advanced/#args_needs_promotion::Bool-Whether-args-need-promotion-to-common-dual-type-(default:-true)","page":"Advanced Usage","title":"args_needs_promotion::Bool - Whether args need promotion to common dual type (default: true)","text":"Internally, pvalue is used to extract the value field from dual numbers and hence build the Dual from the inner most Dual outwards. This requires that all dual numbers in args are of the same type. By default, ift will promote all Dual numbers (in all elements of an Array/tuple and/or fields and nested fields in structs) to type DT. If you have already ensured that all dual numbers in args are of the same type, you can set this parameter to false to skip the promotion step and improve performance. This functionality should be used with caution, as providing for instance dual numbers of different tags will to incorrect results or errors.","category":"section"},{"location":"#IFTDuals.jl","page":"Introduction","title":"IFTDuals.jl","text":"IFTDuals.jl is a lightweight Julia package for computing higher-order derivatives of functions implicitly defined through the Implicit Function Theorem (IFT) using dual numbers. The package enables automatic differentiation for implicit relationships where x=g(theta) is defined implicitly through f(g(theta) theta) = 0.","category":"section"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"The IFT provides a way to compute derivatives of implicitly defined functions. IFTDuals.jl leverages ForwardDiff's dual number system to efficiently compute higher-order derivatives by recursively applying the IFT formulation. Generically, the IFT gives the Kᵗʰ order derivative of x as:\n\nfracpartial^K xpartial theta^K = -leftfracpartial fpartial xright^-1 B_K\n\nWhere B_K, depends on all order of derivatives of y up to order K-1. All previous derivatives hence needs to be computed and stored to compute the next order derivative. IFTDuals.jl obtains the B_K terms recursively, solves for the derivatives and converts the results back into dual numbers. This process is repeated recursively to obtain derivatives of arbitrary order.","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"You can install IFTDuals.jl via Julia's package manager. In the Julia REPL, enter the package manager by pressing ] and then run:\n\npkg> add IFTDuals\n\nAlternatively, you can install directly from the REPL:\n\nusing Pkg\nPkg.add(\"IFTDuals\")","category":"section"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"Here is a minimal example demonstrating how to use IFTDuals.jl:\n\nusing IFTDuals\nusing DifferentiationInterface\nimport ForwardDiff\n\n# Define the implicit function f(x, θ) = 0\nf(x, θ) = ...\n\n# Define a function that solves for y and computes derivatives\nfunction solve_x(θ)\n    θ_primal = nested_pvalue(θ) # Extract primal value, stripping all dual parts\n    x = root_solver(f, θ_primal)  # Use any root solver to find x such that f(x, θ_primal) = 0\n    return ift(x, f, θ, θ_primal) # Compute derivatives if θ contains duals, otherwise return x\nend\n\nθ = 2.0  # Input parameter\n\nvalue_derivative_and_second_derivative(solve_x, AutoForwardDiff(), θ) # computes derivatives using existing frameworks","category":"section"},{"location":"#Contributing","page":"Introduction","title":"Contributing","text":"Contributions to IFTDuals.jl are welcome! If you find a bug or have a feature request, please open an issue on the GitHub repository. If you'd like to contribute code, feel free to fork the repository and submit a pull request.","category":"section"}]
}
