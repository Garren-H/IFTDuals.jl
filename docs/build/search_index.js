var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api.html#IFTDuals.NumEltype-Tuple{V} where V<:Number","page":"API","title":"IFTDuals.NumEltype","text":"    NumEltype(x::V) where V\n    NumEltype(::Type{V}) where V\n\nExtracts the numeric eltype(s) from generic data structures. For structures containing multiple types (e.g. Tuples, Structs, Arrays of structs, Dicts) it returns the eltype of each entry as a Tuple or Array. If the eltype is not a number, we return Nothing. This function is used to check the Dual types contained within data structures. For efficiency, you may provide your own methods for custom data structures e.g.\n\nstruct MyStruct{T<:Number}\n    a::T # variable which may contain Duals\n    b::String # non-numeric variable\nend\n\nNumEltype(x::MyStruct{T}) where T<:Number = T\nNumEltype(::Type{MyStruct{T}}) where T<:Number = T\n\nImportant: If the eltypes is Real or Any, we require x and not just the type V. This is because Real and Any are abstract types used for common propomotion, and do not provide concrete information about the actual types contained within the data structure. If you attempt to pass NumEltype(::Type{Real}) or NumEltype(::Type{Any}), a RealTypeError or AnyTypeError will be thrown, respectively. Instead, provide an instance of the data structure to extract the concrete eltypes.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.check_eltypes-Union{Tuple{Type{V}}, Tuple{V}} where V","page":"API","title":"IFTDuals.check_eltypes","text":"    check_eltypes(::Type{V}) where V\n    check_eltypes(x::Tuple)\n\nChecks if the eltypes contain any Duals. If it does, returns true. This is a helper function intended for internal use.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.make_dual-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{V, Type{<:ForwardDiff.Dual{T, V, N}}, Type{<:ForwardDiff.Partials{N, V}}, Union{AbstractVector{V}, V}}} where {T, V, N}","page":"API","title":"IFTDuals.make_dual","text":"    make_dual(y::V,DT::Type{<:Dual{T,V,N}},PT::Type{<:Partials{N,V}},parts::Union{V,<:AbstractVector{V}}) where {T,V,N}\n\nCreates a Dual number of type DT with value y and partial derivatives given by parts, which can be a scalar or a vector of partial derivatives. If y is a vector, it creates a Vector of Dual numbers accordingly.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.custom_stack-Union{Tuple{Union{AbstractArray{V}, V}}, Tuple{V}} where V<:ForwardDiff.Dual","page":"API","title":"IFTDuals.custom_stack","text":"    custom_stack(x::Union{V,AbstractArray{V}}) where {V<:Dual}\n    custom_stack(x::Union{<:Dual{T,V,N},AbstractArray{<:Dual{T,V,N}}},idx::Union{T2,Vector{T2}}) where {T,V,N,T2<:Union{Int,CartesianIndex{1}}}\n\nStacks the partial derivatives of a Dual (or Vector of Duals) into a Matrix of M x N, where M is the size of the input, N is the number of partials. When an index idx is provided, it returns a Vector, the 'idx'-th partial derivative(s) (idx-th column of the stacked Matrix but efficiently).\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.extract_partials_-Union{Tuple{ForwardDiff.Dual{T, V, N}}, Tuple{N}, Tuple{V}, Tuple{T}} where {T, V, N}","page":"API","title":"IFTDuals.extract_partials_","text":"    extract_partials_(x::Dual{T,V,N}) where {T,N,V}\n    extract_partials_(x::Dual{T,V,N},idx::Union{T2,Vector{T2}}) where {T,V,N,T2<:Union{Int,CartesianIndex{1}}}\n\nExtracts the partials field as a Tuple from a ForwardDiff.Dual. When an index idx is provided, it extracts the idx-th partial derivative.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.extract_values_field_from_partials-Union{Tuple{ForwardDiff.Partials{N, V}}, Tuple{V}, Tuple{N}} where {N, V}","page":"API","title":"IFTDuals.extract_values_field_from_partials","text":"    extract_values_field_from_partials(parts::Partials{N,V}) where {N,V}\n\nExtracts the Tuple from a ForwardDiff.Partials struct. If N==1, it returns a scalar instead of a one-element Tuple.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.get_common_dual_type-Tuple{Any}","page":"API","title":"IFTDuals.get_common_dual_type","text":"    get_common_dual_type(x)\n\nGets the common Dual supertype from the Dual numbers contained within generic data structures. If now Duals present, returns the common numeric supertype. And if no numeric types are present, it should error.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.ift-Union{Tuple{V}, Tuple{Union{AbstractVector{V}, V}, Function, Any}} where V<:Real","page":"API","title":"IFTDuals.ift","text":"    ift(y::Union{V,<:AbstractVector{V}},f::Function,tups) where {V<:Real}\n\nFunction to compute higher-order derivatives using the implicit function theorem and (nested) Dual numbers.  Input:     y    : primal input solution to the root finnding problem (scalar or vector)     f    : function handle that takes 'y' and 'tups' as inputs     tups : tuple or data structure containing Dual numbers indicating the differentiation structure\n\nf(y,tups) = 0 is assumed to define the implicit relationship between y and values given as tups.\n\nNote: This function currently does not support mixed-mode AD, i.e. differentiating wrt different variables given as nested Duals. As a workaround you may concatenate all variables into a single vector and differentiate jointly.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.ift_-Union{Tuple{V2}, Tuple{N}, Tuple{V}, Tuple{T}, Tuple{Union{AbstractVector{V}, V}, Union{AbstractArray{ForwardDiff.Dual{T, V, N}, 1}, ForwardDiff.Dual{T, V, N}}, Union{LinearAlgebra.LU{V2, <:AbstractMatrix{V2}}, V2}}} where {T, V<:Real, N, V2<:Real}","page":"API","title":"IFTDuals.ift_","text":"    ift_(y::Union{V,<:AbstractVector{V}},BNi::Union{Dual{T,V,N},<:AbstractVector{Dual{T,V,N}}},neg_A::Union{V2,<:LU{V2,<:AbstractMatrix{V2},<:AbstractVector{<:Integer}}}) where {T,V<:Real,N,V2<:Real}\n\nFor a given order of differentiation, recusrively computes all directional derivatives using the implicit function theorem and recreates the appropriate ForwardDiff.Dual structure.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.ift_recursive-Union{Tuple{V2}, Tuple{V}, Tuple{Union{AbstractVector{V}, V}, Function, Any, Union{LinearAlgebra.LU{V2, <:AbstractMatrix{V2}}, V2}, Int64}} where {V<:Real, V2<:Real}","page":"API","title":"IFTDuals.ift_recursive","text":"    ift_recursive(y::Union{V,<:AbstractVector{V}},f::Function,tups,neg_A::Union{V2,<:LU{V2,<:AbstractMatrix{V2},<:AbstractVector{<:Integer}}},der_order::Int) where {V<:Real,V2<:Real}\n\nRecursively applies the implicit function theorem to compute higher-order derivatives up to der_order. It evaluates the function f at the current y, solves for the directional derivatives using ift_, and promotes y to the next order of Dual numbers as needed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.nested_pvalue-Tuple{V} where V","page":"API","title":"IFTDuals.nested_pvalue","text":"    nested_pvalue(x::V) where V\n\nExtracts the innermost primal value type(s) from generic data structures containing nested Dual numbers. For V<:Dual, it recursively extracts the valtype until reaching a non-Dual type. For structures containing multiple types (e.g. Tuples, Structs, Arrays of structs, Dicts) it returns the innermost primal value types of each entry as a Tuple or Array. For non-Dual types, it returns the input type as is.\n\nFor generic structure, we have an implementation which attempts to reconstruct the struct type with primal eltypes, but is possible that this may fail. You may consider providing your own method for custom data structures, using recursive calls to pvalue or ForwardDiff.value as needed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.nested_pvalue_type-Union{Tuple{Type{ForwardDiff.Dual{T, V, N}}}, Tuple{N}, Tuple{V}, Tuple{T}} where {T, V, N}","page":"API","title":"IFTDuals.nested_pvalue_type","text":"    nested_pvalue_type(::Type{V}) where V\n\nExtracts the innermost primal value type(s) from generic data structures containing nested Dual numbers. For V<:Dual, it recursively extracts the ForwardDiff.valtype(V) until reaching a non-Dual. For structures containing multiple types (e.g. Tuples, Structs, Arrays of structs, Dicts) it returns the innermost primal value types of each entry as a Tuple or Array. For non-Dual types, it returns the input type as is.\n\nThis function is used to reconstruct struct types with primal eltypes, maintaining eltypes in struct definitions. For generic structure, we have an implementation which attempts to reconstruct the struct type with primal eltypes, but is possible that this may fail. See nested_pvalue for more details.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.promote_common_dual_type-Tuple{Tuple, Type{<:ForwardDiff.Dual}}","page":"API","title":"IFTDuals.promote_common_dual_type","text":"    promote_common_dual_type(x::V, DT::Type{<:Dual}) where V\n\nPromotes Dual numbers in generic data structures to a common Dual type DT. For V<:Dual, it constructs a new instance of DT with the same value and partials as x.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.promote_dual_order-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{V, Type{<:ForwardDiff.Dual{T, V, N}}}} where {T, V, N}","page":"API","title":"IFTDuals.promote_dual_order","text":"    promote_dual_order(y::V,::Type{<:Dual{T,V,N}}) where {T,V,N})\n\nPromotes a Dual number to one of order + 1, seeding the new directional derivatives with zeros. Or if the input is of concrete type Int,Float64,etc, it simply constructs a Dual number of the target type with zero partials.\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.pvalue-Union{Tuple{Type{V}}, Tuple{V}} where V<:ForwardDiff.Dual","page":"API","title":"IFTDuals.pvalue","text":"    pvalue(x::V) where V\n\nExtracts the primal value(s) from generic data structures containing Dual number. For V<:Number, it returns ForwardDiff.value(x) For structures containing multiple types (e.g. Tuples, Structs, Arrays of structs, Dicts) it returns the primal values of each entry as a Tuple or Array. For non-Dual types, it returns the input as is.\n\nIt defaults to returning the input as is. You may consider the following example:\n\nstruct MyStruct{T<:Number}\n    a::T # variable which may contain Duals\n    b::String # non-numeric variable\nend\n\npvalue(x::MyStruct{T}) where T<:Number = MyStruct{ForwardDiff.valtype(T)}(pvalue(x.a), x.b) # construct new struct with primal eltypes\n\n\n\n\n\n","category":"method"},{"location":"api.html#IFTDuals.solve_ift-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{Union{AbstractVector{V}, V}, Union{AbstractVecOrMat{V}, V}, Union{LinearAlgebra.LU{V, <:AbstractMatrix{V}}, V}, Type{<:ForwardDiff.Dual{T, V, N}}}} where {T, V<:Real, N}","page":"API","title":"IFTDuals.solve_ift","text":"    solve_ift(y::Union{V,<:AbstractVector{V}},BNi::Union{V,AbstractVecOrMat{V}},neg_A::Union{V,<:LU{V,<:AbstractMatrix{V},<:AbstractVector{<:Integer}}},DT::Type{<:Dual{T,V,N}}) where {T,V<:Real,N}\n\nSolves the implicit function theorem system for a single directional derivative and constructs Dual numbers of type DT with the computed partial derivatives. This is part of a recursive process to compute higher-order derivatives.\n\n\n\n\n\n","category":"method"},{"location":"index.html#IFTDuals.jl","page":"Home","title":"IFTDuals.jl","text":"Welcome to the documentation for IFTDuals.jl, a Julia package for dual number computations in the context of Implicit Function Theorem applications.","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"IFTDuals\")","category":"section"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"using IFTDuals\nimport ForwardDiff\n\nf(y,x) = ... # system of equations to solve, f(y=g(x),x) = 0 -> solve y\n\nfunction solve_y(x)\n    xp = nested_pvalue(x) # strips all dual parts\n    y = ... # solve for y from f(y,x) using any toolbox/method\n    return ift(y,f,x) # construct dual of y if x contains duals else return x\nend\n\nx = ... # define input\n\ndy = ForwardDiff.gradient(solve_y, x) # can be hessian, jacobian, derivative","category":"section"}]
}
