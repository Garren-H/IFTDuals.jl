var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Reference","page":"API Reference","title":"API Reference","text":"This page provides detailed documentation for the 5 exported functions in IFTDuals.jl.","category":"section"},{"location":"api.html#Main-Function","page":"API Reference","title":"Main Function","text":"","category":"section"},{"location":"api.html#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api.html#IFTDuals.ift","page":"API Reference","title":"IFTDuals.ift","text":"    ift(y::Union{V,<:AbstractVector{V}},f::Function,args) where {V<:Real}\n\nFunction to compute higher-order derivatives using the implicit function theorem and (nested) Dual numbers.  Input:\n\ny    : primal input solution to the root finnding problem (scalar or vector)\nf    : function handle that takes 'y' and 'args' as inputs\nargs : tuple or data structure containing Dual numbers indicating the differentiation structure\n\nf(y,args) = 0 is assumed to define the implicit relationship between y and values given as args.\n\nNote: This function currently does not support mixed-mode AD, i.e. differentiating wrt different variables given as nested Duals. As a workaround you may concatenate all variables into a single vector and differentiate jointly.\n\n\n\n\n\n","category":"function"},{"location":"api.html#IFTDuals.pvalue","page":"API Reference","title":"IFTDuals.pvalue","text":"    pvalue(x::V) where V\n    pvalue(::Type{V}) where V\n\nExtracts the primal value(s) from generic data structures containing Dual number. For V<:Number, it returns ForwardDiff.value(x) For structures containing multiple types (e.g. Tuples, Structs, Arrays of structs, Dicts) it returns the primal values of each entry as a Tuple or Array. For non-Dual types, it returns the input as is. When passing a Type, it returns the corresponding primal eltype(s). The Type signature is only used for reconstructing Types in struct definitions. Hence if you provide a custom method for your struct, the Type signature may not be needed (see below)\n\nWe do attempt to reconstruct struct types with primal eltypes, but this may fail or not be performant for custom data structures. In such cases, you may consider providing your own method for your struct, using recursive calls to pvalue or ForwardDiff.value as needed. For example:\n\nstruct MyStruct{T<:Number}\n    a::T # variable which may contain Duals\n    b::String # non-numeric variable\nend\n\npvalue(x::MyStruct{T}) where T<:Number = MyStruct{ForwardDiff.valtype(T)}(pvalue(x.a), x.b) # construct new struct with primal eltypes\n\n\n\n\n\n","category":"function"},{"location":"api.html#IFTDuals.nested_pvalue","page":"API Reference","title":"IFTDuals.nested_pvalue","text":"    nested_pvalue(x::V) where V\n\nExtracts the innermost primal value type(s) from generic data structures containing nested Dual numbers. For V<:Dual, it recursively extracts the valtype until reaching a non-Dual type. For structures containing multiple types (e.g. Tuples, Structs, Arrays of structs, Dicts) it returns the innermost primal value types of each entry as a Tuple or Array. For non-Dual types, it returns the input type as is.\n\nFor generic structure, we have an implementation which attempts to reconstruct the struct type with primal eltypes, but is possible that this may fail. You may consider providing your own method for custom data structures, using recursive calls to pvalue or ForwardDiff.value as needed.\n\n\n\n\n\n","category":"function"},{"location":"api.html#IFTDuals.promote_common_dual_type","page":"API Reference","title":"IFTDuals.promote_common_dual_type","text":"    promote_common_dual_type(x::V, DT::Type{<:Dual}) where V\n\nPromotes Dual numbers in generic data structures to a common Dual type DT. For V<:Dual, it constructs a new instance of DT with the same value and partials as x.\n\n\n\n\n\n","category":"function"},{"location":"api.html#IFTDuals.promote_my_type","page":"API Reference","title":"IFTDuals.promote_my_type","text":"    promote_my_type(::Type{T}) where T\n    promote_my_type(x::T) where T\n\nGet the common numeric supertype (Duals) from generic data structures. For non-numeric types (String, Symbol, Nothing, Missing, Function), it returns Nothing. For custom data structures, it is recommended to provide your own method for promote_my_type. \n\nExample:\n\nstruct MyStruct{T<:Number}\n    a::T # variable which may contain Duals\n    b::String # non-numeric variable\nend\n\npromote_my_type(::MyStruct{T}) where T<:Number = T # similar to eltype\npromote_my_type(::Type{MyStruct{T}}) where T<:Number = T # my be needed where args contains NTuple{N,MyStruct{T}} types\n\nInternally we call promote_my_type(args) which obtains the numeric types from each entry in args and then reduces over them to get the common numeric supertype. This is hence a combination of Base.eltype and Base.promote_type but specialized to only consider numeric types. An attempt is made to extract the numeric type(s) from custom structs, however this may fail or be non-performant. It is hence highly recommended to provide your own method for custom data structures.\n\n\n\n\n\n","category":"function"},{"location":"examples.html#Examples-and-Tutorials","page":"Examples","title":"Examples and Tutorials","text":"This page provides detailed examples demonstrating various use cases of IFTDuals.jl.","category":"section"},{"location":"examples.html#Example-1:-Simple-Scalar-Implicit-Function","page":"Examples","title":"Example 1: Simple Scalar Implicit Function","text":"Consider the cubic equation:\n\nf(y theta) = y^3 + theta y - 1 = 0\n\nWe want to compute derivatives of the solution y with respect to θ.\n\nusing IFTDuals\nimport ForwardDiff\n\n# Define the implicit equation\nf(y, θ) = y^3 + θ*y - 1\n\n# Solve for y given θ (using Newton's method as an example)\nfunction solve_for_y(θ)\n    y = 1.0  # Initial guess\n    for _ in 1:10\n        y = y - f(y, θ) / (3y^2 + θ)\n    end\n    return y\nend\n\n# Wrapper function that computes derivatives via IFT\nfunction solve_y_with_derivatives(θ)\n    θ_primal = nested_pvalue(θ)\n    y = solve_for_y(θ_primal)\n    return ift(y, f, θ)\nend\n\n# Compute first derivative\nθ = 2.0\ndy_dθ = ForwardDiff.derivative(solve_y_with_derivatives, θ)\n\n# Compute second derivative\nd2y_dθ2 = ForwardDiff.derivative(θ -> ForwardDiff.derivative(solve_y_with_derivatives, θ), θ)\n\nprintln(\"dy/dθ = \", dy_dθ)\nprintln(\"d²y/dθ² = \", d2y_dθ2)","category":"section"},{"location":"examples.html#Example-2:-System-of-Nonlinear-Equations","page":"Examples","title":"Example 2: System of Nonlinear Equations","text":"Consider a system of two equations with two unknowns:\n\nbeginalign\nf_1(y_1 y_2 theta_1 theta_2) = y_1^2 + y_2 - theta_1 = 0 \nf_2(y_1 y_2 theta_1 theta_2) = y_1 + y_2^2 - theta_2 = 0\nendalign\n\nusing IFTDuals\nimport ForwardDiff\nusing LinearAlgebra\n\n# Define the system of equations\nfunction f(y, θ)\n    return [\n        y[1]^2 + y[2] - θ[1],\n        y[1] + y[2]^2 - θ[2]\n    ]\nend\n\n# Solve the system using Newton's method\nfunction solve_system(θ)\n    y = [1.0, 1.0]  # Initial guess\n    \n    for _ in 1:20\n        J = [2*y[1] 1.0; 1.0 2*y[2]]  # Jacobian\n        residual = f(y, θ)\n        y = y - J \\ residual\n        \n        if norm(residual) < 1e-10\n            break\n        end\n    end\n    \n    return y\nend\n\n# Wrapper for IFT\nfunction solve_with_derivatives(θ)\n    θ_primal = nested_pvalue(θ)\n    y = solve_system(θ_primal)\n    return ift(y, f, θ)\nend\n\n# Compute Jacobian matrix dy/dθ\nθ = [1.0, 2.0]\nJ = ForwardDiff.jacobian(solve_with_derivatives, θ)\n\nprintln(\"Jacobian dy/dθ:\")\nprintln(J)","category":"section"},{"location":"examples.html#Example-3:-Optimization-Problem-via-KKT-Conditions","page":"Examples","title":"Example 3: Optimization Problem via KKT Conditions","text":"Consider a constrained optimization problem where the solution satisfies the KKT conditions. We can use IFT to compute derivatives of the optimal solution with respect to problem parameters.\n\nusing IFTDuals\nimport ForwardDiff\n\n# Problem: minimize (x - θ)² subject to x ≥ 0\n# KKT condition: f(x, λ, θ) = [2(x - θ) + λ; λ*x] = 0 with λ ≥ 0, x ≥ 0\n\nfunction kkt_conditions(z, θ)\n    x, λ = z[1], z[2]\n    return [\n        2*(x - θ) + λ,\n        λ*x\n    ]\nend\n\nfunction solve_kkt(θ)\n    # For this simple problem, we know the solution analytically\n    if θ ≥ 0\n        return [θ, 0.0]  # x = θ, λ = 0 (interior solution)\n    else\n        return [0.0, -2*θ]  # x = 0, λ = -2θ (boundary solution)\n    end\nend\n\nfunction optimal_x_with_derivatives(θ)\n    θ_primal = nested_pvalue(θ)\n    z = solve_kkt(θ_primal)\n    z_dual = ift(z, kkt_conditions, θ)\n    return z_dual[1]  # Return only x (not λ)\nend\n\n# Compute derivative of optimal x with respect to θ\nθ = 2.0\ndx_dθ = ForwardDiff.derivative(optimal_x_with_derivatives, θ)\nprintln(\"dx*/dθ = \", dx_dθ)  # Should be 1.0 for θ > 0","category":"section"},{"location":"examples.html#Example-4:-Equilibrium-in-Economics","page":"Examples","title":"Example 4: Equilibrium in Economics","text":"Consider a simple supply-demand equilibrium model where equilibrium price p and quantity q depend on parameters α (demand shifter) and β (supply shifter):\n\nbeginalign\ntextDemand quad q = alpha - p \ntextSupply quad q = beta + p \ntextEquilibrium quad alpha - p = beta + p\nendalign\n\nusing IFTDuals\nimport ForwardDiff\n\n# Define equilibrium conditions as implicit equations\nfunction equilibrium(vars, params)\n    q, p = vars\n    α, β = params\n    return [\n        q - (α - p),  # Demand equation\n        q - (β + p)   # Supply equation\n    ]\nend\n\nfunction solve_equilibrium(params)\n    α, β = nested_pvalue(params)\n    \n    # Analytical solution for this simple case\n    p = (α - β) / 2\n    q = α - p\n    \n    return ift([q, p], equilibrium, params)\nend\n\n# Compute how equilibrium responds to parameter changes\nparams = [10.0, 4.0]  # α = 10, β = 4\nJ = ForwardDiff.jacobian(solve_equilibrium, params)\n\nprintln(\"Equilibrium quantity and price:\")\nqp = solve_equilibrium(params)\nprintln(\"  q = \", nested_pvalue(qp[1]))\nprintln(\"  p = \", nested_pvalue(qp[2]))\n\nprintln(\"\\nSensitivity matrix [dq/dα dq/dβ; dp/dα dp/dβ]:\")\nprintln(J)","category":"section"},{"location":"examples.html#Example-5:-Working-with-Custom-Parameter-Structures","page":"Examples","title":"Example 5: Working with Custom Parameter Structures","text":"When working with complex models, it's often convenient to organize parameters in custom structs:\n\nusing IFTDuals\nimport ForwardDiff\n\n# Define a custom parameter struct\nstruct ModelParams{T<:Real}\n    α::T\n    β::Vector{T}\n    γ::T\n    name::String  # Non-numeric field\nend\n\n# Implement required methods for IFTDuals\nimport IFTDuals: pvalue, nested_pvalue, promote_common_dual_type, promote_my_type\n\npvalue(p::ModelParams{T}) where T = \n    ModelParams{pvalue(T)}(pvalue(p.α), pvalue(p.β), pvalue(p.γ), p.name)\n\nnested_pvalue(p::ModelParams{T}) where T = \n    ModelParams{nested_pvalue(T)}(nested_pvalue(p.α), nested_pvalue(p.β), nested_pvalue(p.γ), p.name)\n\npromote_common_dual_type(p::ModelParams{T}, DT::Type{<:Dual}) where T = \n    ModelParams{DT}(\n        promote_common_dual_type(p.α, DT),\n        promote_common_dual_type(p.β, DT),\n        promote_common_dual_type(p.γ, DT),\n        p.name\n    )\n\npromote_common_dual_type(p::ModelParams{T}, ::Type{T}) where T<:Dual = p\n\npromote_my_type(p::ModelParams{T}) where T = T\npromote_my_type(::Type{ModelParams{T}}) where T = T\n\n# Now use it in an implicit function\nfunction model_equation(y, params::ModelParams)\n    return y^2 + params.α * y + sum(params.β) - params.γ\nend\n\nfunction solve_model(params::ModelParams)\n    p_primal = nested_pvalue(params)\n    \n    # Solve quadratic equation\n    a, b, c = 1.0, p_primal.α, sum(p_primal.β) - p_primal.γ\n    y = (-b + sqrt(b^2 - 4*a*c)) / (2*a)\n    \n    return ift(y, model_equation, params)\nend\n\n# Create parameters and compute derivatives\nparams = ModelParams(2.0, [1.0, 2.0], 5.0, \"test_model\")\n\n# Derivative with respect to α\ndy_dα = ForwardDiff.derivative(α -> solve_model(ModelParams(α, params.β, params.γ, params.name)), params.α)\nprintln(\"dy/dα = \", dy_dα)","category":"section"},{"location":"examples.html#Example-6:-Higher-Order-Derivatives","page":"Examples","title":"Example 6: Higher-Order Derivatives","text":"IFTDuals.jl supports computing higher-order derivatives through nested dual numbers:\n\nusing IFTDuals\nimport ForwardDiff\n\nf(y, θ) = y^3 - θ*y + 1\n\nfunction solve_y(θ)\n    θ_p = nested_pvalue(θ)\n    # Simple fixed-point iteration for this example\n    y = 1.0\n    for _ in 1:20\n        y = cbrt(θ_p * y - 1)\n    end\n    return ift(y, f, θ)\nend\n\nθ = 2.0\n\n# First derivative\ndy_dθ = ForwardDiff.derivative(solve_y, θ)\n\n# Second derivative\nd2y_dθ2 = ForwardDiff.derivative(θ -> ForwardDiff.derivative(solve_y, θ), θ)\n\n# Third derivative\nd3y_dθ3 = ForwardDiff.derivative(\n    θ -> ForwardDiff.derivative(\n        θ -> ForwardDiff.derivative(solve_y, θ), \n        θ\n    ), \n    θ\n)\n\nprintln(\"First derivative:  dy/dθ = \", dy_dθ)\nprintln(\"Second derivative: d²y/dθ² = \", d2y_dθ2)\nprintln(\"Third derivative:  d³y/dθ³ = \", d3y_dθ3)","category":"section"},{"location":"examples.html#Example-7:-Multi-Dimensional-Hessian","page":"Examples","title":"Example 7: Multi-Dimensional Hessian","text":"Computing the Hessian matrix for a vector of parameters:\n\nusing IFTDuals\nimport ForwardDiff\n\nfunction f(y, θ)\n    return [\n        y[1]^2 + y[2] - θ[1] - θ[2],\n        y[1] + y[2]^2 - θ[1]*θ[2]\n    ]\nend\n\nfunction solve_for_y(θ)\n    θ_p = nested_pvalue(θ)\n    # Simplified solver for demonstration\n    y = [sqrt(θ_p[1] + θ_p[2]), sqrt(θ_p[1]*θ_p[2])]\n    return ift(y, f, θ)\nend\n\nθ = [2.0, 3.0]\n\n# Jacobian\nJ = ForwardDiff.jacobian(solve_for_y, θ)\nprintln(\"Jacobian:\")\nprintln(J)\n\n# Hessian of first component y[1] with respect to θ\nH1 = ForwardDiff.hessian(θ -> solve_for_y(θ)[1], θ)\nprintln(\"\\nHessian of y[1]:\")\nprintln(H1)\n\n# Hessian of second component y[2] with respect to θ\nH2 = ForwardDiff.hessian(θ -> solve_for_y(θ)[2], θ)\nprintln(\"\\nHessian of y[2]:\")\nprintln(H2)","category":"section"},{"location":"examples.html#Tips-and-Best-Practices","page":"Examples","title":"Tips and Best Practices","text":"Always extract primal values before solving: Use nested_pvalue to strip all dual number parts before passing to your numerical solver.\nVerify the implicit relationship: Ensure that f(y, args) ≈ 0 holds at the solution before calling ift.\nFor vector systems: Make sure your Jacobian matrix is square (number of equations equals number of unknowns).\nCustom structs: Implement the four key methods (pvalue, nested_pvalue, promote_common_dual_type, promote_my_type) for better performance.\nNumerical stability: If derivatives seem incorrect, check the conditioning of your Jacobian matrix and the accuracy of your primal solution.\nHigher-order derivatives: The computational cost grows with the order of derivatives, but IFTDuals.jl minimizes allocations through efficient wrapper types.","category":"section"},{"location":"advanced.html#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"The ift function accepts several keyword arguments that can improve performance by providing additional information about your differentiation setup. By default, these parameters are auto-detected, but specifying them explicitly can avoid redundant computations.","category":"section"},{"location":"advanced.html#Keyword-Arguments","page":"Advanced Usage","title":"Keyword Arguments","text":"ift(y, f, args; DT=nothing, tag_is_mixed=nothing, args_needs_promotion=true)\nift(y, f, args, args_primal; DT=nothing, tag_is_mixed=nothing, args_needs_promotion=true)","category":"section"},{"location":"advanced.html#args_primal-Primal-value-of-args-(positional-argument)","page":"Advanced Usage","title":"args_primal - Primal value of args (positional argument)","text":"The ift function can accept the primal value of args as a second positional argument. This is particularly useful because you typically need to compute nested_pvalue(args) to solve for the primal solution y anyway. By passing it to ift, you avoid recomputing it internally:\n\nfunction solve_y(θ)\n    θ_primal = nested_pvalue(θ)  # Compute once\n    y = solve_for_y(θ_primal)     # Use to solve for y\n    return ift(y, f, θ, θ_primal) # Pass to ift to avoid recomputation\nend\n\nPerformance benefit: This eliminates the overhead of calling nested_pvalue(args) inside ift, which can be significant for complex nested structures or when ift is called repeatedly.","category":"section"},{"location":"advanced.html#DT::Union{Nothing,Type{:Dual}}-Target-dual-type","page":"Advanced Usage","title":"DT::Union{Nothing,Type{<:Dual}} - Target dual type","text":"By default, ift automatically detects the dual type from args. If you already know the target dual type, you can specify it to skip the type detection step:\n\nusing ForwardDiff\n\n# Manually specify the dual type\nDT = typeof(ForwardDiff.Dual(1.0, 1.0))\ny_dual = ift(y, f, args; DT=DT)\n\nWhen to use: When you're repeatedly calling ift with the same dual type structure and want to avoid the overhead of type detection.","category":"section"},{"location":"advanced.html#tag_is_mixed::Union{Nothing,Bool}-Whether-mixed-tags-are-present","page":"Advanced Usage","title":"tag_is_mixed::Union{Nothing,Bool} - Whether mixed tags are present","text":"By default, ift checks whether args contains mixed tags (different variables with different tags). If you know whether your setup uses mixed tags, you can specify this to skip the check:\n\n# For single tag (symmetric) mode\ny_dual = ift(y, f, args; tag_is_mixed=false)\n\n# For mixed tags mode (cross-derivatives)\ny_dual = ift(y, f, args; tag_is_mixed=true)\n\nImportant details:\n\nPerformance with DT: Even when you specify tag_is_mixed, the package still validates this against the dual types in args. For maximum performance, you should also specify DT to avoid the dual type detection step:\n# Most efficient approach\ny_dual = ift(y, f, args; DT=DT, tag_is_mixed=false)\nInternal validation: If DT is not provided, it will be computed internally from args and then used to validate the tag_is_mixed parameter.\nError conditions: If mixed tags are detected in DT (different function signatures in tag types) but the partials fields have different numbers of entries, an error will be thrown. This helps catch configuration mistakes.\nValid usage of tag_is_mixed=false: Setting tag_is_mixed=false is only valid when all partials fields in the nested dual structure have the same number of partials. This ensures the symmetric derivative structure assumption holds throughout the recursion.\n\nWhen to use:\n\nSet to false when working with single-tag (symmetric) derivatives for optimal performance. This is the most common case and uses the more efficient implementation.\nSet to true when computing cross-derivatives like d²g/dx₁dx₂ where you need derivatives with respect to different variables (each having its own tag).","category":"section"},{"location":"advanced.html#args_needs_promotion::Bool-Whether-args-need-promotion-to-common-dual-type-(default:-true)","page":"Advanced Usage","title":"args_needs_promotion::Bool - Whether args need promotion to common dual type (default: true)","text":"When computing higher-order derivatives, ift may need to promote args to a common dual type. If you've already ensured all duals in args have the same type, you can skip this promotion step:\n\n# If args already has a common dual type\ny_dual = ift(y, f, args; args_needs_promotion=false)\n\nWhen to use: When you've already ensured type consistency in args and want to avoid the promotion overhead.","category":"section"},{"location":"advanced.html#Performance-Examples","page":"Advanced Usage","title":"Performance Examples","text":"","category":"section"},{"location":"advanced.html#Basic-Optimization","page":"Advanced Usage","title":"Basic Optimization","text":"using IFTDuals\nimport ForwardDiff\n\nf(y, θ) = y^3 + θ*y - 1\n\nfunction solve_y_optimized(θ)\n    θ_primal = nested_pvalue(θ)\n    y = solve_for_y(θ_primal)\n    \n    # Pass θ_primal to avoid recomputation and specify single tag mode\n    return ift(y, f, θ, θ_primal; tag_is_mixed=false)\nend","category":"section"},{"location":"advanced.html#Second-Order-Derivatives-with-Full-Optimization","page":"Advanced Usage","title":"Second-Order Derivatives with Full Optimization","text":"function solve_y_second_order(θ)\n    θ_primal = nested_pvalue(θ)\n    y = solve_for_y(θ_primal)\n    \n    # Get the dual type from θ\n    DT = typeof(θ)\n    \n    # Skip all auto-detection for maximum performance\n    return ift(y, f, θ, θ_primal; DT=DT, tag_is_mixed=false, args_needs_promotion=false)\nend\n\n# Compute second derivative\nθ = 2.0\nd2y_dθ2 = ForwardDiff.derivative(θ -> ForwardDiff.derivative(solve_y_second_order, θ), θ)","category":"section"},{"location":"advanced.html#Vector-System-with-Optimization","page":"Advanced Usage","title":"Vector System with Optimization","text":"function f(y, θ)\n    return [\n        y[1]^2 + y[2] - θ[1],\n        y[1] + y[2]^2 - θ[2]\n    ]\nend\n\nfunction solve_system_optimized(θ)\n    θ_primal = nested_pvalue(θ)\n    y = numerical_solver(f, θ_primal)\n    \n    # For vector systems, optimization can provide significant speedups\n    return ift(y, f, θ, θ_primal; tag_is_mixed=false)\nend","category":"section"},{"location":"advanced.html#Benchmarking-Example","page":"Advanced Usage","title":"Benchmarking Example","text":"Here's how to benchmark the difference between auto-detection and manual specification:\n\nusing BenchmarkTools\nusing IFTDuals\nimport ForwardDiff\n\nf(y, θ) = y^3 + θ*y - 1\n\nfunction solve_y_auto(θ)\n    θ_primal = nested_pvalue(θ)\n    y = θ_primal^(1/3)  # Simplified solver\n    return ift(y, f, θ)  # Auto-detect everything\nend\n\nfunction solve_y_manual(θ)\n    θ_primal = nested_pvalue(θ)\n    y = θ_primal^(1/3)\n    DT = typeof(θ)\n    return ift(y, f, θ, θ_primal; DT=DT, tag_is_mixed=false, args_needs_promotion=false)\nend\n\nθ = 2.0\n\n# Benchmark auto-detection\n@benchmark ForwardDiff.derivative(solve_y_auto, $θ)\n\n# Benchmark manual specification\n@benchmark ForwardDiff.derivative(solve_y_manual, $θ)","category":"section"},{"location":"advanced.html#Recommendations","page":"Advanced Usage","title":"Recommendations","text":"Start simple: Begin with the basic ift(y, f, args) call without keyword arguments. The auto-detection is fast and correct.\nAlways pass args_primal: Since you typically need to compute nested_pvalue(args) to solve for the primal solution anyway, passing it to ift is essentially free and avoids redundant computation:\nargs_primal = nested_pvalue(args)\ny = solve_for_y(args_primal)\nreturn ift(y, f, args, args_primal)  # Recommended pattern\nProfile first: Only add other optimization keywords after profiling shows that type detection is a bottleneck.\nUse tag_is_mixed=false liberally: If you're using single-tag mode (most common case), setting this to false is generally safe and can provide noticeable speedups.\nCombine optimizations: For maximum performance in tight loops, combine all optimizations when you have complete knowledge of your dual type structure:\nreturn ift(y, f, args, args_primal; DT=DT, tag_is_mixed=false, args_needs_promotion=false)\nBe cautious with args_needs_promotion=false: Only use this when you're certain all duals in args already have the same type, or you may get incorrect results.","category":"section"},{"location":"advanced.html#When-Auto-Detection-is-Preferred","page":"Advanced Usage","title":"When Auto-Detection is Preferred","text":"In most cases, the auto-detection overhead is negligible compared to the computational cost of:\n\nSolving the implicit equation\nComputing Jacobians\nLU decomposition (for vector systems)\n\nUse auto-detection (the default) when:\n\nYou're computing derivatives only once or a few times\nYour implicit function solve is expensive (most common case)\nCode clarity is more important than micro-optimizations\nYou're prototyping or developing new models\n\nThe keyword arguments are most beneficial when:\n\nCalling ift in tight loops with many iterations\nThe implicit solve is very cheap\nYou've profiled and identified type detection as a bottleneck\nYou're implementing high-performance libraries","category":"section"},{"location":"index.html#IFTDuals.jl","page":"Home","title":"IFTDuals.jl","text":"IFTDuals.jl is a lightweight Julia package for computing higher-order derivatives of functions implicitly defined through the Implicit Function Theorem (IFT) using dual numbers. The package enables automatic differentiation for implicit relationships where x=g(theta) is defined implicitly through f(g(theta) theta) = 0.","category":"section"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"The Implicit Function Theorem provides a way to compute derivatives of implicitly defined functions. IFTDuals.jl leverages ForwardDiff's dual number system to efficiently compute higher-order derivatives by recursively applying the IFT formulation.","category":"section"},{"location":"index.html#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"index.html#Mixed-tags","page":"Home","title":"Mixed tags","text":"The package supports two differentiation modes:\n\nSingle tag (symmetric): All variables use the same tag. This assumes partials.value == value.partials (symmetric derivative structures). This is the default and most efficient mode, suitable for computing derivatives like d²g/dx₁² and d²g/dx₂².\nMixed tags: Different variables each have their own tag. This is useful when you need cross-derivatives such as d²g/dx₁dx₂ and not d²g/dx₁² nor d²g/dx₂². While mixed tags work correctly, they incur performance penalties when computing multiple directional derivatives due to the additional bookkeeping required to track different tags through the recursive process.\n\nFor most applications, using a single tag (concatenating all parameters into a single vector) will provide the best performance.","category":"section"},{"location":"index.html#Mutation-of-arguments","page":"Home","title":"Mutation of arguments","text":"Variables being differentiated (i.e., args passed to ift) should not be mutated within your function f or any intermediate computations. The args structure is reused throughout the recursive process when computing higher-order derivatives. While mutation may work correctly for first-order Duals, it will lead to incorrect results for higher-order derivatives (second-order and above).\n\nRecommendation: If your function requires mutating the input arguments, create an intermediate function that copies args before passing it to your computation:\n\nfunction f_safe(y, args)\n    args_copy = deepcopy(args)  # Create a copy to avoid mutation issues\n    # Now safe to mutate args_copy\n    return f_original(y, args_copy)\nend\n\n# Use f_safe instead of f_original in ift\ny_dual = ift(y, f_safe, args)\n\nNote that this approach may incur a performance penalty due to the copying overhead.","category":"section"},{"location":"index.html#Function-signature","page":"Home","title":"Function signature","text":"The ift function only supports the two-argument function signature f(x, args). If your implicit function requires multiple separate parameter arguments, you should define args as a tuple and use splatting within your function:\n\n# If you have a function with multiple parameters\nfunction my_function(x, α, β, γ)\n    return ... # some operation\nend\n\n# Wrap it to use the f(y, theta) signature\nf(x, args) = my_function(x, args...)\n\n# Define theta as a tuple of parameters\nargs = (α, β, γ)\n\n# Now you can use ift\nx_dual = ift(x, f, args)","category":"section"},{"location":"index.html#Automatic-differentiation-backend","page":"Home","title":"Automatic differentiation backend","text":"This package was developed specifically to work with ForwardDiff.jl and its dual number implementation. It is not designed to work with other automatic differentiation packages (such as ReverseDiff.jl, Zygote.jl, or Enzyme.jl). All differentiation operations should be performed using ForwardDiff.jl.","category":"section"},{"location":"index.html#Array-type-annotations","page":"Home","title":"Array type annotations","text":"If args (and/or x) contain arrays with dual numbers, any functions or methods you define should use AbstractArray type annotations rather than concrete Array types. This is because IFTDuals.jl uses intermediate AbstractArray subtypes (such as PValueArray, NestedPValueArray, SeedDualArray, and PartialsArray) for efficient non-allocating operations on dual number arrays.\n\nRecommendation: Use AbstractArray, AbstractVector, or AbstractMatrix in your type signatures:\n\n# Good - works with IFTDuals wrapper types\nfunction my_function(y::AbstractVector, args::AbstractVector)\n    # ... your code\nend\n\n# Bad - may fail with IFTDuals wrapper types\nfunction my_function(y::Vector, args::Vector)\n    # ... your code\nend\n\nThis ensures compatibility with the wrapper types used internally by the package for performance optimization.","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"You can install IFTDuals.jl via Julia's package manager. In the Julia REPL, enter the package manager by pressing ] and then run:\n\npkg> add IFTDuals\n\nAlternatively, you can install directly from the REPL:\n\nusing Pkg\nPkg.add(\"IFTDuals\")","category":"section"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"Here is a minimal example demonstrating how to use IFTDuals.jl:\n\nusing IFTDuals\nusing DifferentiationInterface\nimport ForwardDiff\n\n# Define the implicit function f(y, θ) = 0\nf(y, θ) = y^3 + θ*y - 1\n\n# Define a function that solves for y and computes derivatives\nfunction solve_y(θ)\n    θ_primal = nested_pvalue(θ) # Extract primal value, stripping all dual parts\n    y = root_solver(f, θ_primal)  # Use any root solver to find y such that f(y, θ_primal) = 0\n    return ift(y, f, θ) # Compute derivatives if θ contains duals, otherwise return y\nend\n\nθ = 2.0  # Input parameter\ndy_dθ = ForwardDiff.derivative(solve_y, θ) # First derivative\nd2y_dθ2 = ForwardDiff.derivative(θ -> ForwardDiff.derivative(solve_y, θ), θ) # Second derivative","category":"section"},{"location":"index.html#Key-Concepts","page":"Home","title":"Key Concepts","text":"","category":"section"},{"location":"index.html#Implicit-Function-Theorem","page":"Home","title":"Implicit Function Theorem","text":"For a system of equations f(y theta) = 0 where y depends implicitly on theta, the IFT gives us:\n\nfracpartial ypartial theta = -leftfracpartial fpartial yright^-1 fracpartial fpartial theta\n\nIFTDuals.jl recursively applies this relationship to compute higher-order derivatives efficiently using nested dual numbers.","category":"section"},{"location":"index.html#Dual-Numbers","page":"Home","title":"Dual Numbers","text":"The package relies on ForwardDiff's dual number representation to propagate derivatives through the implicit relationship. When you pass dual numbers as arguments, the ift function automatically computes the appropriate derivatives and reconstructs the dual number structure.","category":"section"},{"location":"index.html#Exported-Functions","page":"Home","title":"Exported Functions","text":"IFTDuals.jl exports five main functions:\n\nift: Computes higher-order derivatives using the Implicit Function Theorem\npvalue: Extracts the primal value from dual numbers\nnested_pvalue: Recursively extracts the innermost primal value from nested duals\npromote_common_dual_type: Promotes all dual numbers to a common type\npromote_my_type: Extracts and promotes the underlying numeric type from data structures\n\nSee the API Reference for detailed documentation of each function.","category":"section"},{"location":"index.html#Basic-Usage-Examples","page":"Home","title":"Basic Usage Examples","text":"","category":"section"},{"location":"index.html#Scalar-Case","page":"Home","title":"Scalar Case","text":"using IFTDuals\nimport ForwardDiff\n\n# Implicit equation: y^2 + θ*y - 1 = 0\nf(y, θ) = y^2 + θ*y - 1\n\nfunction get_y(θ)\n    θ_p = nested_pvalue(θ)\n    # Solve for y (using any root finding method)\n    y = (-θ_p + sqrt(θ_p^2 + 4)) / 2\n    return ift(y, f, θ)\nend\n\n# Compute first derivative\ndy_dθ = ForwardDiff.derivative(get_y, 1.0)\n\n# Compute second derivative\nd2y_dθ2 = ForwardDiff.derivative(θ -> ForwardDiff.derivative(get_y, θ), 1.0)","category":"section"},{"location":"index.html#Vector-Case","page":"Home","title":"Vector Case","text":"using IFTDuals\nimport ForwardDiff\n\n# System of equations: f(y, θ) = 0\nfunction f(y, θ)\n    return [\n        y[1]^2 + y[2] - θ[1],\n        y[1] + y[2]^2 - θ[2]\n    ]\nend\n\nfunction solve_system(θ)\n    θ_p = nested_pvalue(θ)\n    # Solve the system for y (using any solver)\n    y = ... # your solver here\n    return ift(y, f, θ)\nend\n\nθ = [1.0, 2.0]\nJ = ForwardDiff.jacobian(solve_system, θ)  # Jacobian matrix","category":"section"},{"location":"index.html#Working-with-Custom-Structs","page":"Home","title":"Working with Custom Structs","text":"For custom data structures passed as arguments to ift, it's highly recommended to provide custom implementations of pvalue, nested_pvalue, promote_common_dual_type, and promote_my_type:\n\nstruct MyParams{T<:Real}\n    a::Vector{T}\n    b::T\n    c::String  # Non-differentiable field\nend\n\n# Extract primal value\npvalue(p::MyParams{T}) where T = MyParams{pvalue(T)}(pvalue(p.a), pvalue(p.b), p.c)\n\n# Extract nested primal value\nnested_pvalue(p::MyParams{T}) where T = MyParams{nested_pvalue(T)}(\n    nested_pvalue(p.a), nested_pvalue(p.b), p.c\n)\n\n# Promote to common dual type\npromote_common_dual_type(p::MyParams{T}, DT::Type{<:Dual}) where T = \n    MyParams{DT}(promote_common_dual_type(p.a, DT), promote_common_dual_type(p.b, DT), p.c)\n\n# Already correct type (optimization)\npromote_common_dual_type(p::MyParams{T}, ::Type{T}) where T<:Dual = p\n\n# Extract numeric type (similar to eltype)\npromote_my_type(p::MyParams{T}) where T = T\npromote_my_type(::Type{MyParams{T}}) where T = T","category":"section"},{"location":"index.html#Performance-Considerations","page":"Home","title":"Performance Considerations","text":"The package uses non-allocating wrapper types (PValueArray, NestedPValueArray, SeedDualArray, PartialsArray) to efficiently extract and manipulate dual number components without unnecessary allocations.\nFor vector-valued functions, the Jacobian matrix is computed once and factored using LU decomposition for efficient repeated solves during derivative computation.\nCustom implementations of pvalue, nested_pvalue, and promote_my_type for your data structures can significantly improve performance.","category":"section"},{"location":"index.html#Contributing","page":"Home","title":"Contributing","text":"Contributions to IFTDuals.jl are welcome! If you find a bug or have a feature request, please open an issue on the GitHub repository. If you'd like to contribute code, feel free to fork the repository and submit a pull request.","category":"section"},{"location":"index.html#License","page":"Home","title":"License","text":"This project is licensed under the MIT License - see the LICENSE file for details.","category":"section"}]
}
