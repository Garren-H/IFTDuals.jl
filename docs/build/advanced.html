<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced Usage · IFTDuals.jl</title><meta name="title" content="Advanced Usage · IFTDuals.jl"/><meta property="og:title" content="Advanced Usage · IFTDuals.jl"/><meta property="twitter:title" content="Advanced Usage · IFTDuals.jl"/><meta name="description" content="Documentation for IFTDuals.jl."/><meta property="og:description" content="Documentation for IFTDuals.jl."/><meta property="twitter:description" content="Documentation for IFTDuals.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">IFTDuals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="examples.html">Examples</a></li><li class="is-active"><a class="tocitem" href="advanced.html">Advanced Usage</a><ul class="internal"><li><a class="tocitem" href="#Keyword-Arguments"><span>Keyword Arguments</span></a></li><li><a class="tocitem" href="#Performance-Examples"><span>Performance Examples</span></a></li><li><a class="tocitem" href="#Benchmarking-Example"><span>Benchmarking Example</span></a></li><li><a class="tocitem" href="#Recommendations"><span>Recommendations</span></a></li><li><a class="tocitem" href="#When-Auto-Detection-is-Preferred"><span>When Auto-Detection is Preferred</span></a></li></ul></li><li><a class="tocitem" href="api.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="advanced.html">Advanced Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="advanced.html">Advanced Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Garren-H/IFTDuals.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Garren-H/IFTDuals.jl/blob/main/docs/src/advanced.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Advanced-Usage"><a class="docs-heading-anchor" href="#Advanced-Usage">Advanced Usage</a><a id="Advanced-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Usage" title="Permalink"></a></h1><p>The <code>ift</code> function accepts several keyword arguments that can improve performance by providing additional information about your differentiation setup. By default, these parameters are auto-detected, but specifying them explicitly can avoid redundant computations.</p><h2 id="Keyword-Arguments"><a class="docs-heading-anchor" href="#Keyword-Arguments">Keyword Arguments</a><a id="Keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-Arguments" title="Permalink"></a></h2><pre><code class="language-julia hljs">ift(y, f, args; DT=nothing, tag_is_mixed=nothing, args_needs_promotion=true)
ift(y, f, args, args_primal; DT=nothing, tag_is_mixed=nothing, args_needs_promotion=true)</code></pre><h3 id="args_primal-Primal-value-of-args-(positional-argument)"><a class="docs-heading-anchor" href="#args_primal-Primal-value-of-args-(positional-argument)"><code>args_primal</code> - Primal value of args (positional argument)</a><a id="args_primal-Primal-value-of-args-(positional-argument)-1"></a><a class="docs-heading-anchor-permalink" href="#args_primal-Primal-value-of-args-(positional-argument)" title="Permalink"></a></h3><p>The <code>ift</code> function can accept the primal value of <code>args</code> as a second positional argument. This is particularly useful because you typically need to compute <code>nested_pvalue(args)</code> to solve for the primal solution <code>y</code> anyway. By passing it to <code>ift</code>, you avoid recomputing it internally:</p><pre><code class="language-julia hljs">function solve_y(θ)
    θ_primal = nested_pvalue(θ)  # Compute once
    y = solve_for_y(θ_primal)     # Use to solve for y
    return ift(y, f, θ, θ_primal) # Pass to ift to avoid recomputation
end</code></pre><p><strong>Performance benefit</strong>: This eliminates the overhead of calling <code>nested_pvalue(args)</code> inside <code>ift</code>, which can be significant for complex nested structures or when <code>ift</code> is called repeatedly.</p><h3 id="DT::Union{Nothing,Type{:Dual}}-Target-dual-type"><a class="docs-heading-anchor" href="#DT::Union{Nothing,Type{:Dual}}-Target-dual-type"><code>DT::Union{Nothing,Type{&lt;:Dual}}</code> - Target dual type</a><a id="DT::Union{Nothing,Type{:Dual}}-Target-dual-type-1"></a><a class="docs-heading-anchor-permalink" href="#DT::Union{Nothing,Type{:Dual}}-Target-dual-type" title="Permalink"></a></h3><p>By default, <code>ift</code> automatically detects the dual type from <code>args</code>. If you already know the target dual type, you can specify it to skip the type detection step:</p><pre><code class="language-julia hljs">using ForwardDiff

# Manually specify the dual type
DT = typeof(ForwardDiff.Dual(1.0, 1.0))
y_dual = ift(y, f, args; DT=DT)</code></pre><p><strong>When to use</strong>: When you&#39;re repeatedly calling <code>ift</code> with the same dual type structure and want to avoid the overhead of type detection.</p><h3 id="tag_is_mixed::Union{Nothing,Bool}-Whether-mixed-tags-are-present"><a class="docs-heading-anchor" href="#tag_is_mixed::Union{Nothing,Bool}-Whether-mixed-tags-are-present"><code>tag_is_mixed::Union{Nothing,Bool}</code> - Whether mixed tags are present</a><a id="tag_is_mixed::Union{Nothing,Bool}-Whether-mixed-tags-are-present-1"></a><a class="docs-heading-anchor-permalink" href="#tag_is_mixed::Union{Nothing,Bool}-Whether-mixed-tags-are-present" title="Permalink"></a></h3><p>By default, <code>ift</code> checks whether <code>args</code> contains mixed tags (different variables with different tags). If you know whether your setup uses mixed tags, you can specify this to skip the check:</p><pre><code class="language-julia hljs"># For single tag (symmetric) mode
y_dual = ift(y, f, args; tag_is_mixed=false)

# For mixed tags mode (cross-derivatives)
y_dual = ift(y, f, args; tag_is_mixed=true)</code></pre><p><strong>Important details</strong>:</p><ol><li><p><strong>Performance with <code>DT</code></strong>: Even when you specify <code>tag_is_mixed</code>, the package still validates this against the dual types in <code>args</code>. For maximum performance, you should also specify <code>DT</code> to avoid the dual type detection step:</p><pre><code class="language-julia hljs"># Most efficient approach
y_dual = ift(y, f, args; DT=DT, tag_is_mixed=false)</code></pre></li><li><p><strong>Internal validation</strong>: If <code>DT</code> is not provided, it will be computed internally from <code>args</code> and then used to validate the <code>tag_is_mixed</code> parameter.</p></li><li><p><strong>Error conditions</strong>: If mixed tags are detected in <code>DT</code> (different function signatures in tag types) but the partials fields have different numbers of entries, an error will be thrown. This helps catch configuration mistakes.</p></li><li><p><strong>Valid usage of <code>tag_is_mixed=false</code></strong>: Setting <code>tag_is_mixed=false</code> is only valid when all partials fields in the nested dual structure have the same number of partials. This ensures the symmetric derivative structure assumption holds throughout the recursion.</p></li></ol><p><strong>When to use</strong>:</p><ul><li>Set to <code>false</code> when working with single-tag (symmetric) derivatives for optimal performance. This is the most common case and uses the more efficient implementation.</li><li>Set to <code>true</code> when computing cross-derivatives like d²g/dx₁dx₂ where you need derivatives with respect to different variables (each having its own tag).</li></ul><h3 id="args_needs_promotion::Bool-Whether-args-need-promotion-to-common-dual-type-(default:-true)"><a class="docs-heading-anchor" href="#args_needs_promotion::Bool-Whether-args-need-promotion-to-common-dual-type-(default:-true)"><code>args_needs_promotion::Bool</code> - Whether args need promotion to common dual type (default: <code>true</code>)</a><a id="args_needs_promotion::Bool-Whether-args-need-promotion-to-common-dual-type-(default:-true)-1"></a><a class="docs-heading-anchor-permalink" href="#args_needs_promotion::Bool-Whether-args-need-promotion-to-common-dual-type-(default:-true)" title="Permalink"></a></h3><p>When computing higher-order derivatives, <code>ift</code> may need to promote <code>args</code> to a common dual type. If you&#39;ve already ensured all duals in <code>args</code> have the same type, you can skip this promotion step:</p><pre><code class="language-julia hljs"># If args already has a common dual type
y_dual = ift(y, f, args; args_needs_promotion=false)</code></pre><p><strong>When to use</strong>: When you&#39;ve already ensured type consistency in <code>args</code> and want to avoid the promotion overhead.</p><h2 id="Performance-Examples"><a class="docs-heading-anchor" href="#Performance-Examples">Performance Examples</a><a id="Performance-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Examples" title="Permalink"></a></h2><h3 id="Basic-Optimization"><a class="docs-heading-anchor" href="#Basic-Optimization">Basic Optimization</a><a id="Basic-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Optimization" title="Permalink"></a></h3><pre><code class="language-julia hljs">using IFTDuals
import ForwardDiff

f(y, θ) = y^3 + θ*y - 1

function solve_y_optimized(θ)
    θ_primal = nested_pvalue(θ)
    y = solve_for_y(θ_primal)
    
    # Pass θ_primal to avoid recomputation and specify single tag mode
    return ift(y, f, θ, θ_primal; tag_is_mixed=false)
end</code></pre><h3 id="Second-Order-Derivatives-with-Full-Optimization"><a class="docs-heading-anchor" href="#Second-Order-Derivatives-with-Full-Optimization">Second-Order Derivatives with Full Optimization</a><a id="Second-Order-Derivatives-with-Full-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Second-Order-Derivatives-with-Full-Optimization" title="Permalink"></a></h3><pre><code class="language-julia hljs">function solve_y_second_order(θ)
    θ_primal = nested_pvalue(θ)
    y = solve_for_y(θ_primal)
    
    # Get the dual type from θ
    DT = typeof(θ)
    
    # Skip all auto-detection for maximum performance
    return ift(y, f, θ, θ_primal; DT=DT, tag_is_mixed=false, args_needs_promotion=false)
end

# Compute second derivative
θ = 2.0
d2y_dθ2 = ForwardDiff.derivative(θ -&gt; ForwardDiff.derivative(solve_y_second_order, θ), θ)</code></pre><h3 id="Vector-System-with-Optimization"><a class="docs-heading-anchor" href="#Vector-System-with-Optimization">Vector System with Optimization</a><a id="Vector-System-with-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-System-with-Optimization" title="Permalink"></a></h3><pre><code class="language-julia hljs">function f(y, θ)
    return [
        y[1]^2 + y[2] - θ[1],
        y[1] + y[2]^2 - θ[2]
    ]
end

function solve_system_optimized(θ)
    θ_primal = nested_pvalue(θ)
    y = numerical_solver(f, θ_primal)
    
    # For vector systems, optimization can provide significant speedups
    return ift(y, f, θ, θ_primal; tag_is_mixed=false)
end</code></pre><h2 id="Benchmarking-Example"><a class="docs-heading-anchor" href="#Benchmarking-Example">Benchmarking Example</a><a id="Benchmarking-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarking-Example" title="Permalink"></a></h2><p>Here&#39;s how to benchmark the difference between auto-detection and manual specification:</p><pre><code class="language-julia hljs">using BenchmarkTools
using IFTDuals
import ForwardDiff

f(y, θ) = y^3 + θ*y - 1

function solve_y_auto(θ)
    θ_primal = nested_pvalue(θ)
    y = θ_primal^(1/3)  # Simplified solver
    return ift(y, f, θ)  # Auto-detect everything
end

function solve_y_manual(θ)
    θ_primal = nested_pvalue(θ)
    y = θ_primal^(1/3)
    DT = typeof(θ)
    return ift(y, f, θ, θ_primal; DT=DT, tag_is_mixed=false, args_needs_promotion=false)
end

θ = 2.0

# Benchmark auto-detection
@benchmark ForwardDiff.derivative(solve_y_auto, $θ)

# Benchmark manual specification
@benchmark ForwardDiff.derivative(solve_y_manual, $θ)</code></pre><h2 id="Recommendations"><a class="docs-heading-anchor" href="#Recommendations">Recommendations</a><a id="Recommendations-1"></a><a class="docs-heading-anchor-permalink" href="#Recommendations" title="Permalink"></a></h2><ol><li><p><strong>Start simple</strong>: Begin with the basic <code>ift(y, f, args)</code> call without keyword arguments. The auto-detection is fast and correct.</p></li><li><p><strong>Always pass <code>args_primal</code></strong>: Since you typically need to compute <code>nested_pvalue(args)</code> to solve for the primal solution anyway, passing it to <code>ift</code> is essentially free and avoids redundant computation:</p><pre><code class="language-julia hljs">args_primal = nested_pvalue(args)
y = solve_for_y(args_primal)
return ift(y, f, args, args_primal)  # Recommended pattern</code></pre></li><li><p><strong>Profile first</strong>: Only add other optimization keywords after profiling shows that type detection is a bottleneck.</p></li><li><p><strong>Use <code>tag_is_mixed=false</code> liberally</strong>: If you&#39;re using single-tag mode (most common case), setting this to <code>false</code> is generally safe and can provide noticeable speedups.</p></li><li><p><strong>Combine optimizations</strong>: For maximum performance in tight loops, combine all optimizations when you have complete knowledge of your dual type structure:</p><pre><code class="language-julia hljs">return ift(y, f, args, args_primal; DT=DT, tag_is_mixed=false, args_needs_promotion=false)</code></pre></li><li><p><strong>Be cautious with <code>args_needs_promotion=false</code></strong>: Only use this when you&#39;re certain all duals in <code>args</code> already have the same type, or you may get incorrect results.</p></li></ol><h2 id="When-Auto-Detection-is-Preferred"><a class="docs-heading-anchor" href="#When-Auto-Detection-is-Preferred">When Auto-Detection is Preferred</a><a id="When-Auto-Detection-is-Preferred-1"></a><a class="docs-heading-anchor-permalink" href="#When-Auto-Detection-is-Preferred" title="Permalink"></a></h2><p>In most cases, the auto-detection overhead is negligible compared to the computational cost of:</p><ul><li>Solving the implicit equation</li><li>Computing Jacobians</li><li>LU decomposition (for vector systems)</li></ul><p>Use auto-detection (the default) when:</p><ul><li>You&#39;re computing derivatives only once or a few times</li><li>Your implicit function solve is expensive (most common case)</li><li>Code clarity is more important than micro-optimizations</li><li>You&#39;re prototyping or developing new models</li></ul><p>The keyword arguments are most beneficial when:</p><ul><li>Calling <code>ift</code> in tight loops with many iterations</li><li>The implicit solve is very cheap</li><li>You&#39;ve profiled and identified type detection as a bottleneck</li><li>You&#39;re implementing high-performance libraries</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="examples.html">« Examples</a><a class="docs-footer-nextpage" href="api.html">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 1 February 2026 03:43">Sunday 1 February 2026</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
