<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · IFTDuals.jl</title><meta name="title" content="Home · IFTDuals.jl"/><meta property="og:title" content="Home · IFTDuals.jl"/><meta property="twitter:title" content="Home · IFTDuals.jl"/><meta name="description" content="Documentation for IFTDuals.jl."/><meta property="og:description" content="Documentation for IFTDuals.jl."/><meta property="twitter:description" content="Documentation for IFTDuals.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">IFTDuals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Home</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Limitations"><span>Limitations</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Key-Concepts"><span>Key Concepts</span></a></li><li><a class="tocitem" href="#Exported-Functions"><span>Exported Functions</span></a></li><li><a class="tocitem" href="#Basic-Usage-Examples"><span>Basic Usage Examples</span></a></li><li><a class="tocitem" href="#Working-with-Custom-Structs"><span>Working with Custom Structs</span></a></li><li><a class="tocitem" href="#Performance-Considerations"><span>Performance Considerations</span></a></li><li><a class="tocitem" href="#Contributing"><span>Contributing</span></a></li><li><a class="tocitem" href="#License"><span>License</span></a></li></ul></li><li><a class="tocitem" href="examples.html">Examples</a></li><li><a class="tocitem" href="advanced.html">Advanced Usage</a></li><li><a class="tocitem" href="api.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Garren-H/IFTDuals.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Garren-H/IFTDuals.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="IFTDuals.jl"><a class="docs-heading-anchor" href="#IFTDuals.jl">IFTDuals.jl</a><a id="IFTDuals.jl-1"></a><a class="docs-heading-anchor-permalink" href="#IFTDuals.jl" title="Permalink"></a></h1><p>IFTDuals.jl is a lightweight Julia package for computing higher-order derivatives of functions implicitly defined through the Implicit Function Theorem (IFT) using dual numbers. The package enables automatic differentiation for implicit relationships where <span>$x=g(\theta)$</span> is defined implicitly through <span>$f(g(\theta), \theta) = 0$</span>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The Implicit Function Theorem provides a way to compute derivatives of implicitly defined functions. IFTDuals.jl leverages ForwardDiff&#39;s dual number system to efficiently compute higher-order derivatives by recursively applying the IFT formulation.</p><h2 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h2><h3 id="Mixed-tags"><a class="docs-heading-anchor" href="#Mixed-tags">Mixed tags</a><a id="Mixed-tags-1"></a><a class="docs-heading-anchor-permalink" href="#Mixed-tags" title="Permalink"></a></h3><p>The package supports two differentiation modes:</p><ul><li><strong>Single tag (symmetric)</strong>: All variables use the same tag. This assumes <code>partials.value == value.partials</code> (symmetric derivative structures). This is the default and most efficient mode, suitable for computing derivatives like d²g/dx₁² and d²g/dx₂².</li><li><strong>Mixed tags</strong>: Different variables each have their own tag. This is useful when you need cross-derivatives such as d²g/dx₁dx₂ and not d²g/dx₁² nor d²g/dx₂². While mixed tags work correctly, they incur performance penalties when computing multiple directional derivatives due to the additional bookkeeping required to track different tags through the recursive process.</li></ul><p>For most applications, using a single tag (concatenating all parameters into a single vector) will provide the best performance.</p><h3 id="Mutation-of-arguments"><a class="docs-heading-anchor" href="#Mutation-of-arguments">Mutation of arguments</a><a id="Mutation-of-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Mutation-of-arguments" title="Permalink"></a></h3><p>Variables being differentiated (i.e., <code>args</code> passed to <code>ift</code>) should <strong>not be mutated</strong> within your function <code>f</code> or any intermediate computations. The <code>args</code> structure is reused throughout the recursive process when computing higher-order derivatives. While mutation may work correctly for first-order Duals, it will lead to incorrect results for higher-order derivatives (second-order and above).</p><p><strong>Recommendation</strong>: If your function requires mutating the input arguments, create an intermediate function that copies <code>args</code> before passing it to your computation:</p><pre><code class="language-julia hljs">function f_safe(y, args)
    args_copy = deepcopy(args)  # Create a copy to avoid mutation issues
    # Now safe to mutate args_copy
    return f_original(y, args_copy)
end

# Use f_safe instead of f_original in ift
y_dual = ift(y, f_safe, args)</code></pre><p>Note that this approach may incur a performance penalty due to the copying overhead.</p><h3 id="Function-signature"><a class="docs-heading-anchor" href="#Function-signature">Function signature</a><a id="Function-signature-1"></a><a class="docs-heading-anchor-permalink" href="#Function-signature" title="Permalink"></a></h3><p>The <code>ift</code> function only supports the two-argument function signature <code>f(x, args)</code>. If your implicit function requires multiple separate parameter arguments, you should define <code>args</code> as a tuple and use splatting within your function:</p><pre><code class="language-julia hljs"># If you have a function with multiple parameters
function my_function(x, α, β, γ)
    return ... # some operation
end

# Wrap it to use the f(y, theta) signature
f(x, args) = my_function(x, args...)

# Define theta as a tuple of parameters
args = (α, β, γ)

# Now you can use ift
x_dual = ift(x, f, args)</code></pre><h3 id="Automatic-differentiation-backend"><a class="docs-heading-anchor" href="#Automatic-differentiation-backend">Automatic differentiation backend</a><a id="Automatic-differentiation-backend-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-differentiation-backend" title="Permalink"></a></h3><p>This package was developed specifically to work with ForwardDiff.jl and its dual number implementation. It is not designed to work with other automatic differentiation packages (such as ReverseDiff.jl, Zygote.jl, or Enzyme.jl). All differentiation operations should be performed using ForwardDiff.jl.</p><h3 id="Array-type-annotations"><a class="docs-heading-anchor" href="#Array-type-annotations">Array type annotations</a><a id="Array-type-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#Array-type-annotations" title="Permalink"></a></h3><p>If <code>args</code> (and/or <code>x</code>) contain arrays with dual numbers, any functions or methods you define should use <code>AbstractArray</code> type annotations rather than concrete <code>Array</code> types. This is because IFTDuals.jl uses intermediate <code>AbstractArray</code> subtypes (such as <code>PValueArray</code>, <code>NestedPValueArray</code>, <code>SeedDualArray</code>, and <code>PartialsArray</code>) for efficient non-allocating operations on dual number arrays.</p><p><strong>Recommendation</strong>: Use <code>AbstractArray</code>, <code>AbstractVector</code>, or <code>AbstractMatrix</code> in your type signatures:</p><pre><code class="language-julia hljs"># Good - works with IFTDuals wrapper types
function my_function(y::AbstractVector, args::AbstractVector)
    # ... your code
end

# Bad - may fail with IFTDuals wrapper types
function my_function(y::Vector, args::Vector)
    # ... your code
end</code></pre><p>This ensures compatibility with the wrapper types used internally by the package for performance optimization.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>You can install IFTDuals.jl via Julia&#39;s package manager. In the Julia REPL, enter the package manager by pressing <code>]</code> and then run:</p><pre><code class="language-julia hljs">pkg&gt; add IFTDuals</code></pre><p>Alternatively, you can install directly from the REPL:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;IFTDuals&quot;)</code></pre><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><p>Here is a minimal example demonstrating how to use IFTDuals.jl:</p><pre><code class="language-julia hljs">using IFTDuals
using DifferentiationInterface
import ForwardDiff

# Define the implicit function f(y, θ) = 0
f(y, θ) = y^3 + θ*y - 1

# Define a function that solves for y and computes derivatives
function solve_y(θ)
    θ_primal = nested_pvalue(θ) # Extract primal value, stripping all dual parts
    y = root_solver(f, θ_primal)  # Use any root solver to find y such that f(y, θ_primal) = 0
    return ift(y, f, θ) # Compute derivatives if θ contains duals, otherwise return y
end

θ = 2.0  # Input parameter
dy_dθ = ForwardDiff.derivative(solve_y, θ) # First derivative
d2y_dθ2 = ForwardDiff.derivative(θ -&gt; ForwardDiff.derivative(solve_y, θ), θ) # Second derivative</code></pre><h2 id="Key-Concepts"><a class="docs-heading-anchor" href="#Key-Concepts">Key Concepts</a><a id="Key-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Concepts" title="Permalink"></a></h2><h3 id="Implicit-Function-Theorem"><a class="docs-heading-anchor" href="#Implicit-Function-Theorem">Implicit Function Theorem</a><a id="Implicit-Function-Theorem-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-Function-Theorem" title="Permalink"></a></h3><p>For a system of equations <span>$f(y, \theta) = 0$</span> where <span>$y$</span> depends implicitly on <span>$\theta$</span>, the IFT gives us:</p><p class="math-container">\[\frac{\partial y}{\partial \theta} = -\left[\frac{\partial f}{\partial y}\right]^{-1} \frac{\partial f}{\partial \theta}\]</p><p>IFTDuals.jl recursively applies this relationship to compute higher-order derivatives efficiently using nested dual numbers.</p><h3 id="Dual-Numbers"><a class="docs-heading-anchor" href="#Dual-Numbers">Dual Numbers</a><a id="Dual-Numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-Numbers" title="Permalink"></a></h3><p>The package relies on ForwardDiff&#39;s dual number representation to propagate derivatives through the implicit relationship. When you pass dual numbers as arguments, the <code>ift</code> function automatically computes the appropriate derivatives and reconstructs the dual number structure.</p><h2 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h2><p>IFTDuals.jl exports five main functions:</p><ul><li><strong><code>ift</code></strong>: Computes higher-order derivatives using the Implicit Function Theorem</li><li><strong><code>pvalue</code></strong>: Extracts the primal value from dual numbers</li><li><strong><code>nested_pvalue</code></strong>: Recursively extracts the innermost primal value from nested duals</li><li><strong><code>promote_common_dual_type</code></strong>: Promotes all dual numbers to a common type</li><li><strong><code>promote_my_type</code></strong>: Extracts and promotes the underlying numeric type from data structures</li></ul><p>See the <a href="api.html#API-Reference">API Reference</a> for detailed documentation of each function.</p><h2 id="Basic-Usage-Examples"><a class="docs-heading-anchor" href="#Basic-Usage-Examples">Basic Usage Examples</a><a id="Basic-Usage-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-Examples" title="Permalink"></a></h2><h3 id="Scalar-Case"><a class="docs-heading-anchor" href="#Scalar-Case">Scalar Case</a><a id="Scalar-Case-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Case" title="Permalink"></a></h3><pre><code class="language-julia hljs">using IFTDuals
import ForwardDiff

# Implicit equation: y^2 + θ*y - 1 = 0
f(y, θ) = y^2 + θ*y - 1

function get_y(θ)
    θ_p = nested_pvalue(θ)
    # Solve for y (using any root finding method)
    y = (-θ_p + sqrt(θ_p^2 + 4)) / 2
    return ift(y, f, θ)
end

# Compute first derivative
dy_dθ = ForwardDiff.derivative(get_y, 1.0)

# Compute second derivative
d2y_dθ2 = ForwardDiff.derivative(θ -&gt; ForwardDiff.derivative(get_y, θ), 1.0)</code></pre><h3 id="Vector-Case"><a class="docs-heading-anchor" href="#Vector-Case">Vector Case</a><a id="Vector-Case-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Case" title="Permalink"></a></h3><pre><code class="language-julia hljs">using IFTDuals
import ForwardDiff

# System of equations: f(y, θ) = 0
function f(y, θ)
    return [
        y[1]^2 + y[2] - θ[1],
        y[1] + y[2]^2 - θ[2]
    ]
end

function solve_system(θ)
    θ_p = nested_pvalue(θ)
    # Solve the system for y (using any solver)
    y = ... # your solver here
    return ift(y, f, θ)
end

θ = [1.0, 2.0]
J = ForwardDiff.jacobian(solve_system, θ)  # Jacobian matrix</code></pre><h2 id="Working-with-Custom-Structs"><a class="docs-heading-anchor" href="#Working-with-Custom-Structs">Working with Custom Structs</a><a id="Working-with-Custom-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Custom-Structs" title="Permalink"></a></h2><p>For custom data structures passed as arguments to <code>ift</code>, it&#39;s highly recommended to provide custom implementations of <code>pvalue</code>, <code>nested_pvalue</code>, <code>promote_common_dual_type</code>, and <code>promote_my_type</code>:</p><pre><code class="language-julia hljs">struct MyParams{T&lt;:Real}
    a::Vector{T}
    b::T
    c::String  # Non-differentiable field
end

# Extract primal value
pvalue(p::MyParams{T}) where T = MyParams{pvalue(T)}(pvalue(p.a), pvalue(p.b), p.c)

# Extract nested primal value
nested_pvalue(p::MyParams{T}) where T = MyParams{nested_pvalue(T)}(
    nested_pvalue(p.a), nested_pvalue(p.b), p.c
)

# Promote to common dual type
promote_common_dual_type(p::MyParams{T}, DT::Type{&lt;:Dual}) where T = 
    MyParams{DT}(promote_common_dual_type(p.a, DT), promote_common_dual_type(p.b, DT), p.c)

# Already correct type (optimization)
promote_common_dual_type(p::MyParams{T}, ::Type{T}) where T&lt;:Dual = p

# Extract numeric type (similar to eltype)
promote_my_type(p::MyParams{T}) where T = T
promote_my_type(::Type{MyParams{T}}) where T = T</code></pre><h2 id="Performance-Considerations"><a class="docs-heading-anchor" href="#Performance-Considerations">Performance Considerations</a><a id="Performance-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Considerations" title="Permalink"></a></h2><ul><li>The package uses non-allocating wrapper types (<code>PValueArray</code>, <code>NestedPValueArray</code>, <code>SeedDualArray</code>, <code>PartialsArray</code>) to efficiently extract and manipulate dual number components without unnecessary allocations.</li><li>For vector-valued functions, the Jacobian matrix is computed once and factored using LU decomposition for efficient repeated solves during derivative computation.</li><li>Custom implementations of <code>pvalue</code>, <code>nested_pvalue</code>, and <code>promote_my_type</code> for your data structures can significantly improve performance.</li></ul><h2 id="Contributing"><a class="docs-heading-anchor" href="#Contributing">Contributing</a><a id="Contributing-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing" title="Permalink"></a></h2><p>Contributions to IFTDuals.jl are welcome! If you find a bug or have a feature request, please open an issue on the <a href="https://github.com/Garren-H/IFTDuals.jl/issues">GitHub repository</a>. If you&#39;d like to contribute code, feel free to fork the repository and submit a pull request.</p><h2 id="License"><a class="docs-heading-anchor" href="#License">License</a><a id="License-1"></a><a class="docs-heading-anchor-permalink" href="#License" title="Permalink"></a></h2><p>This project is licensed under the MIT License - see the LICENSE file for details.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples.html">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 1 February 2026 03:43">Sunday 1 February 2026</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
