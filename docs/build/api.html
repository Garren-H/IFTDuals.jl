<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · IFTDuals.jl</title><meta name="title" content="API · IFTDuals.jl"/><meta property="og:title" content="API · IFTDuals.jl"/><meta property="twitter:title" content="API · IFTDuals.jl"/><meta name="description" content="Documentation for IFTDuals.jl."/><meta property="og:description" content="Documentation for IFTDuals.jl."/><meta property="twitter:description" content="Documentation for IFTDuals.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">IFTDuals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Garren-H/IFTDuals.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Garren-H/IFTDuals.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><ul><li><a href="api.html#IFTDuals.NumEltype-Tuple{V} where V&lt;:Number"><code>IFTDuals.NumEltype</code></a></li><li><a href="api.html#IFTDuals.check_eltypes-Union{Tuple{Type{V}}, Tuple{V}} where V"><code>IFTDuals.check_eltypes</code></a></li><li><a href="api.html#IFTDuals.make_dual-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{V, Type{&lt;:ForwardDiff.Dual{T, V, N}}, Type{&lt;:ForwardDiff.Partials{N, V}}, Union{AbstractVector{V}, V}}} where {T, V, N}"><code>IFTDuals.make_dual</code></a></li><li><a href="api.html#IFTDuals.custom_stack-Union{Tuple{Union{AbstractArray{V}, V}}, Tuple{V}} where V&lt;:ForwardDiff.Dual"><code>IFTDuals.custom_stack</code></a></li><li><a href="api.html#IFTDuals.extract_partials_-Union{Tuple{ForwardDiff.Dual{T, V, N}}, Tuple{N}, Tuple{V}, Tuple{T}} where {T, V, N}"><code>IFTDuals.extract_partials_</code></a></li><li><a href="api.html#IFTDuals.extract_values_field_from_partials-Union{Tuple{ForwardDiff.Partials{N, V}}, Tuple{V}, Tuple{N}} where {N, V}"><code>IFTDuals.extract_values_field_from_partials</code></a></li><li><a href="api.html#IFTDuals.get_common_dual_type-Tuple{Any}"><code>IFTDuals.get_common_dual_type</code></a></li><li><a href="api.html#IFTDuals.ift-Union{Tuple{V}, Tuple{Union{AbstractVector{V}, V}, Function, Any}} where V&lt;:Real"><code>IFTDuals.ift</code></a></li><li><a href="api.html#IFTDuals.ift_-Union{Tuple{V2}, Tuple{N}, Tuple{V}, Tuple{T}, Tuple{Union{AbstractVector{V}, V}, Union{AbstractArray{ForwardDiff.Dual{T, V, N}, 1}, ForwardDiff.Dual{T, V, N}}, Union{LinearAlgebra.LU{V2, &lt;:AbstractMatrix{V2}}, V2}}} where {T, V&lt;:Real, N, V2&lt;:Real}"><code>IFTDuals.ift_</code></a></li><li><a href="api.html#IFTDuals.ift_recursive-Union{Tuple{V2}, Tuple{V}, Tuple{Union{AbstractVector{V}, V}, Function, Any, Union{LinearAlgebra.LU{V2, &lt;:AbstractMatrix{V2}}, V2}, Int64}} where {V&lt;:Real, V2&lt;:Real}"><code>IFTDuals.ift_recursive</code></a></li><li><a href="api.html#IFTDuals.nested_pvalue-Tuple{V} where V"><code>IFTDuals.nested_pvalue</code></a></li><li><a href="api.html#IFTDuals.nested_pvalue_type-Union{Tuple{Type{ForwardDiff.Dual{T, V, N}}}, Tuple{N}, Tuple{V}, Tuple{T}} where {T, V, N}"><code>IFTDuals.nested_pvalue_type</code></a></li><li><a href="api.html#IFTDuals.promote_common_dual_type-Tuple{Tuple, Type{&lt;:ForwardDiff.Dual}}"><code>IFTDuals.promote_common_dual_type</code></a></li><li><a href="api.html#IFTDuals.seed_nested_dual-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{V, Type{&lt;:ForwardDiff.Dual{T, V, N}}}} where {T, V, N}"><code>IFTDuals.seed_nested_dual</code></a></li><li><a href="api.html#IFTDuals.pvalue-Union{Tuple{Type{V}}, Tuple{V}} where V&lt;:ForwardDiff.Dual"><code>IFTDuals.pvalue</code></a></li><li><a href="api.html#IFTDuals.solve_ift-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{Union{AbstractVector{V}, V}, Union{AbstractVecOrMat{V}, V}, Union{LinearAlgebra.LU{V, &lt;:AbstractMatrix{V}}, V}, Type{&lt;:ForwardDiff.Dual{T, V, N}}}} where {T, V&lt;:Real, N}"><code>IFTDuals.solve_ift</code></a></li></ul><article><details class="docstring" open="true"><summary id="IFTDuals.NumEltype-Tuple{V} where V&lt;:Number"><a class="docstring-binding" href="#IFTDuals.NumEltype-Tuple{V} where V&lt;:Number"><code>IFTDuals.NumEltype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    NumEltype(x::V) where V
    NumEltype(::Type{V}) where V</code></pre><p>Extracts the numeric eltype(s) from generic data structures. For structures containing multiple types (e.g. Tuples, Structs, Arrays of structs, Dicts) it returns the eltype of each entry as a Tuple or Array. If the eltype is not a number, we return <code>Nothing</code>. This function is used to check the Dual types contained within data structures. For efficiency, you may provide your own methods for custom data structures e.g.</p><pre><code class="language-julia hljs">struct MyStruct{T&lt;:Number}
    a::T # variable which may contain Duals
    b::String # non-numeric variable
end

NumEltype(x::MyStruct{T}) where T&lt;:Number = T
NumEltype(::Type{MyStruct{T}}) where T&lt;:Number = T</code></pre><p>Important: If the eltypes is <code>Real</code> or <code>Any</code>, we require <code>x</code> and not just the type <code>V</code>. This is because <code>Real</code> and <code>Any</code> are abstract types used for common propomotion, and do not provide concrete information about the actual types contained within the data structure. If you attempt to pass <code>NumEltype(::Type{Real})</code> or <code>NumEltype(::Type{Any})</code>, a <code>RealTypeError</code> or <code>AnyTypeError</code> will be thrown, respectively. Instead, provide an instance of the data structure to extract the concrete eltypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/utils.jl#L3-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.check_eltypes-Union{Tuple{Type{V}}, Tuple{V}} where V"><a class="docstring-binding" href="#IFTDuals.check_eltypes-Union{Tuple{Type{V}}, Tuple{V}} where V"><code>IFTDuals.check_eltypes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    check_eltypes(::Type{V}) where V
    check_eltypes(x::Tuple)</code></pre><p>Checks if the eltypes contain any Duals. If it does, returns true. This is a helper function intended for internal use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/utils.jl#L113-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.make_dual-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{V, Type{&lt;:ForwardDiff.Dual{T, V, N}}, Type{&lt;:ForwardDiff.Partials{N, V}}, Union{AbstractVector{V}, V}}} where {T, V, N}"><a class="docstring-binding" href="#IFTDuals.make_dual-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{V, Type{&lt;:ForwardDiff.Dual{T, V, N}}, Type{&lt;:ForwardDiff.Partials{N, V}}, Union{AbstractVector{V}, V}}} where {T, V, N}"><code>IFTDuals.make_dual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    make_dual(y::V,DT::Type{&lt;:Dual{T,V,N}},PT::Type{&lt;:Partials{N,V}},parts::Union{V,&lt;:AbstractVector{V}}) where {T,V,N}</code></pre><p>Creates a <code>Dual</code> number of type <code>DT</code> with value <code>y</code> and partial derivatives given by <code>parts</code>, which can be a scalar or a vector of partial derivatives. If <code>y</code> is a vector, it creates a Vector of <code>Dual</code> numbers accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/derivatives.jl#L58-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.custom_stack-Union{Tuple{Union{AbstractArray{V}, V}}, Tuple{V}} where V&lt;:ForwardDiff.Dual"><a class="docstring-binding" href="#IFTDuals.custom_stack-Union{Tuple{Union{AbstractArray{V}, V}}, Tuple{V}} where V&lt;:ForwardDiff.Dual"><code>IFTDuals.custom_stack</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    custom_stack(x::Union{V,AbstractArray{V}}) where {V&lt;:Dual}
    custom_stack(x::Union{&lt;:Dual{T,V,N},AbstractArray{&lt;:Dual{T,V,N}}},idx::Union{T2,Vector{T2}}) where {T,V,N,T2&lt;:Union{Int,CartesianIndex{1}}}</code></pre><p>Stacks the partial derivatives of a Dual (or Vector of Duals) into a Matrix of M x N, where M is the size of the input, N is the number of partials. When an index <code>idx</code> is provided, it returns a Vector, the &#39;idx&#39;-th partial derivative(s) (<code>idx</code>-th column of the stacked Matrix but efficiently).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/derivatives.jl#L44-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.extract_partials_-Union{Tuple{ForwardDiff.Dual{T, V, N}}, Tuple{N}, Tuple{V}, Tuple{T}} where {T, V, N}"><a class="docstring-binding" href="#IFTDuals.extract_partials_-Union{Tuple{ForwardDiff.Dual{T, V, N}}, Tuple{N}, Tuple{V}, Tuple{T}} where {T, V, N}"><code>IFTDuals.extract_partials_</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    extract_partials_(x::Dual{T,V,N}) where {T,N,V}
    extract_partials_(x::Dual{T,V,N},idx::Union{T2,Vector{T2}}) where {T,V,N,T2&lt;:Union{Int,CartesianIndex{1}}}</code></pre><p>Extracts the <code>partials</code> field as a <code>Tuple</code> from a <code>ForwardDiff.Dual</code>. When an index <code>idx</code> is provided, it extracts the <code>idx</code>-th partial derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/derivatives.jl#L32-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.extract_values_field_from_partials-Union{Tuple{ForwardDiff.Partials{N, V}}, Tuple{V}, Tuple{N}} where {N, V}"><a class="docstring-binding" href="#IFTDuals.extract_values_field_from_partials-Union{Tuple{ForwardDiff.Partials{N, V}}, Tuple{V}, Tuple{N}} where {N, V}"><code>IFTDuals.extract_values_field_from_partials</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    extract_values_field_from_partials(parts::Partials{N,V}) where {N,V}</code></pre><p>Extracts the <code>Tuple</code> from a <code>ForwardDiff.Partials</code> struct. If <code>N==1</code>, it returns a scalar instead of a one-element Tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/derivatives.jl#L24-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.get_common_dual_type-Tuple{Any}"><a class="docstring-binding" href="#IFTDuals.get_common_dual_type-Tuple{Any}"><code>IFTDuals.get_common_dual_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    get_common_dual_type(x)</code></pre><p>Gets the common Dual supertype from the Dual numbers contained within generic data structures. If now Duals present, returns the common numeric supertype. And if no numeric types are present, it should error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/utils.jl#L225-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.ift-Union{Tuple{V}, Tuple{Union{AbstractVector{V}, V}, Function, Any}} where V&lt;:Real"><a class="docstring-binding" href="#IFTDuals.ift-Union{Tuple{V}, Tuple{Union{AbstractVector{V}, V}, Function, Any}} where V&lt;:Real"><code>IFTDuals.ift</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    ift(y::Union{V,&lt;:AbstractVector{V}},f::Function,tups) where {V&lt;:Real}</code></pre><p>Function to compute higher-order derivatives using the implicit function theorem and (nested) Dual numbers.  Input:     <code>y</code>    : primal input solution to the root finnding problem (scalar or vector)     <code>f</code>    : function handle that takes &#39;y&#39; and &#39;tups&#39; as inputs     <code>tups</code> : tuple or data structure containing Dual numbers indicating the differentiation structure</p><p><code>f(y,tups) = 0</code> is assumed to define the implicit relationship between <code>y</code> and values given as <code>tups</code>.</p><p><strong>Note</strong>: This function currently does not support mixed-mode AD, i.e. differentiating wrt different variables given as nested Duals. As a workaround you may concatenate all variables into a single vector and differentiate jointly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/derivatives.jl#L120-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.ift_-Union{Tuple{V2}, Tuple{N}, Tuple{V}, Tuple{T}, Tuple{Union{AbstractVector{V}, V}, Union{AbstractArray{ForwardDiff.Dual{T, V, N}, 1}, ForwardDiff.Dual{T, V, N}}, Union{LinearAlgebra.LU{V2, &lt;:AbstractMatrix{V2}}, V2}}} where {T, V&lt;:Real, N, V2&lt;:Real}"><a class="docstring-binding" href="#IFTDuals.ift_-Union{Tuple{V2}, Tuple{N}, Tuple{V}, Tuple{T}, Tuple{Union{AbstractVector{V}, V}, Union{AbstractArray{ForwardDiff.Dual{T, V, N}, 1}, ForwardDiff.Dual{T, V, N}}, Union{LinearAlgebra.LU{V2, &lt;:AbstractMatrix{V2}}, V2}}} where {T, V&lt;:Real, N, V2&lt;:Real}"><code>IFTDuals.ift_</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    ift_(y::Union{V,&lt;:AbstractVector{V}},BNi::Union{Dual{T,V,N},&lt;:AbstractVector{Dual{T,V,N}}},neg_A::Union{V2,&lt;:LU{V2,&lt;:AbstractMatrix{V2},&lt;:AbstractVector{&lt;:Integer}}}) where {T,V&lt;:Real,N,V2&lt;:Real}</code></pre><p>For a given order of differentiation, recusrively computes all directional derivatives using the implicit function theorem and recreates the appropriate <code>ForwardDiff.Dual</code> structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/derivatives.jl#L80-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.ift_recursive-Union{Tuple{V2}, Tuple{V}, Tuple{Union{AbstractVector{V}, V}, Function, Any, Union{LinearAlgebra.LU{V2, &lt;:AbstractMatrix{V2}}, V2}, Int64}} where {V&lt;:Real, V2&lt;:Real}"><a class="docstring-binding" href="#IFTDuals.ift_recursive-Union{Tuple{V2}, Tuple{V}, Tuple{Union{AbstractVector{V}, V}, Function, Any, Union{LinearAlgebra.LU{V2, &lt;:AbstractMatrix{V2}}, V2}, Int64}} where {V&lt;:Real, V2&lt;:Real}"><code>IFTDuals.ift_recursive</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    ift_recursive(y::Union{V,&lt;:AbstractVector{V}},f::Function,tups,neg_A::Union{V2,&lt;:LU{V2,&lt;:AbstractMatrix{V2},&lt;:AbstractVector{&lt;:Integer}}},der_order::Int) where {V&lt;:Real,V2&lt;:Real}</code></pre><p>Recursively applies the implicit function theorem to compute higher-order derivatives up to <code>der_order</code>. It evaluates the function <code>f</code> at the current <code>y</code>, solves for the directional derivatives using <code>ift_</code>, and promotes <code>y</code> to the next order of <code>Dual</code> numbers as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/derivatives.jl#L102-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.nested_pvalue-Tuple{V} where V"><a class="docstring-binding" href="#IFTDuals.nested_pvalue-Tuple{V} where V"><code>IFTDuals.nested_pvalue</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    nested_pvalue(x::V) where V</code></pre><p>Extracts the innermost primal value type(s) from generic data structures containing nested Dual numbers. For <code>V&lt;:Dual</code>, it recursively extracts the valtype until reaching a non-Dual type. For structures containing multiple types (e.g. Tuples, Structs, Arrays of structs, Dicts) it returns the innermost primal value types of each entry as a Tuple or Array. For non-Dual types, it returns the input type as is.</p><p>For generic structure, we have an implementation which attempts to reconstruct the struct type with primal eltypes, but is possible that this may fail. You may consider providing your own method for custom data structures, using recursive calls to <code>pvalue</code> or <code>ForwardDiff.value</code> as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/utils.jl#L154-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.nested_pvalue_type-Union{Tuple{Type{ForwardDiff.Dual{T, V, N}}}, Tuple{N}, Tuple{V}, Tuple{T}} where {T, V, N}"><a class="docstring-binding" href="#IFTDuals.nested_pvalue_type-Union{Tuple{Type{ForwardDiff.Dual{T, V, N}}}, Tuple{N}, Tuple{V}, Tuple{T}} where {T, V, N}"><code>IFTDuals.nested_pvalue_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    nested_pvalue_type(::Type{V}) where V</code></pre><p>Extracts the innermost primal value type(s) from generic data structures containing nested Dual numbers. For <code>V&lt;:Dual</code>, it recursively extracts the ForwardDiff.valtype(V) until reaching a non-Dual. For structures containing multiple types (e.g. Tuples, Structs, Arrays of structs, Dicts) it returns the innermost primal value types of each entry as a Tuple or Array. For non-Dual types, it returns the input type as is.</p><p>This function is used to reconstruct struct types with primal eltypes, maintaining eltypes in struct definitions. For generic structure, we have an implementation which attempts to reconstruct the struct type with primal eltypes, but is possible that this may fail. See <code>nested_pvalue</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/utils.jl#L124-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.promote_common_dual_type-Tuple{Tuple, Type{&lt;:ForwardDiff.Dual}}"><a class="docstring-binding" href="#IFTDuals.promote_common_dual_type-Tuple{Tuple, Type{&lt;:ForwardDiff.Dual}}"><code>IFTDuals.promote_common_dual_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    promote_common_dual_type(x::V, DT::Type{&lt;:Dual}) where V</code></pre><p>Promotes Dual numbers in generic data structures to a common Dual type <code>DT</code>. For <code>V&lt;:Dual</code>, it constructs a new instance of <code>DT</code> with the same value and partials as <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/utils.jl#L188-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.seed_nested_dual-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{V, Type{&lt;:ForwardDiff.Dual{T, V, N}}}} where {T, V, N}"><a class="docstring-binding" href="#IFTDuals.seed_nested_dual-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{V, Type{&lt;:ForwardDiff.Dual{T, V, N}}}} where {T, V, N}"><code>IFTDuals.seed_nested_dual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    seed_nested_dual(y::V,::Type{&lt;:Dual{T,V,N}}) where {T,V,N})</code></pre><p>Promotes a <code>Dual</code> number to one of order + 1, seeding the new directional derivatives with zeros. Or if the input is of concrete type Int,Float64,etc, it simply constructs a Dual number of the target type with zero partials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/derivatives.jl#L2-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.pvalue-Union{Tuple{Type{V}}, Tuple{V}} where V&lt;:ForwardDiff.Dual"><a class="docstring-binding" href="#IFTDuals.pvalue-Union{Tuple{Type{V}}, Tuple{V}} where V&lt;:ForwardDiff.Dual"><code>IFTDuals.pvalue</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    pvalue(x::V) where V</code></pre><p>Extracts the primal value(s) from generic data structures containing Dual number. For <code>V&lt;:Number</code>, it returns ForwardDiff.value(x) For structures containing multiple types (e.g. Tuples, Structs, Arrays of structs, Dicts) it returns the primal values of each entry as a Tuple or Array. For non-Dual types, it returns the input as is.</p><p>It defaults to returning the input as is. You may consider the following example:</p><pre><code class="language-julia hljs">struct MyStruct{T&lt;:Number}
    a::T # variable which may contain Duals
    b::String # non-numeric variable
end

pvalue(x::MyStruct{T}) where T&lt;:Number = MyStruct{ForwardDiff.valtype(T)}(pvalue(x.a), x.b) # construct new struct with primal eltypes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/utils.jl#L52-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="IFTDuals.solve_ift-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{Union{AbstractVector{V}, V}, Union{AbstractVecOrMat{V}, V}, Union{LinearAlgebra.LU{V, &lt;:AbstractMatrix{V}}, V}, Type{&lt;:ForwardDiff.Dual{T, V, N}}}} where {T, V&lt;:Real, N}"><a class="docstring-binding" href="#IFTDuals.solve_ift-Union{Tuple{N}, Tuple{V}, Tuple{T}, Tuple{Union{AbstractVector{V}, V}, Union{AbstractVecOrMat{V}, V}, Union{LinearAlgebra.LU{V, &lt;:AbstractMatrix{V}}, V}, Type{&lt;:ForwardDiff.Dual{T, V, N}}}} where {T, V&lt;:Real, N}"><code>IFTDuals.solve_ift</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">    solve_ift(y::Union{V,&lt;:AbstractVector{V}},BNi::Union{V,AbstractVecOrMat{V}},neg_A::Union{V,&lt;:LU{V,&lt;:AbstractMatrix{V},&lt;:AbstractVector{&lt;:Integer}}},DT::Type{&lt;:Dual{T,V,N}}) where {T,V&lt;:Real,N}</code></pre><p>Solves the implicit function theorem system for a single directional derivative and constructs <code>Dual</code> numbers of type <code>DT</code> with the computed partial derivatives. This is part of a recursive process to compute higher-order derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Garren-H/IFTDuals.jl/blob/3a4b5f4bf343a35624e3aa0c39ba5796c1fd29e1/src/derivatives.jl#L67-L72">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 19 January 2026 21:25">Monday 19 January 2026</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
